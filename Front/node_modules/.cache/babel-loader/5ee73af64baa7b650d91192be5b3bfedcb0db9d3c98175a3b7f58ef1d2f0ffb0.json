{"ast":null,"code":"'use strict';\n\nconst Errors = require('../misc/errors');\n\n/**\n * Object to easily parse buffer.\n * Packet are MUTABLE (buffer are changed, to avoid massive packet object creation).\n * Use clone() in case immutability is required\n *\n */\nclass Packet {\n  update(buf, pos, end) {\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n    return this;\n  }\n  skip(n) {\n    this.pos += n;\n  }\n  readGeometry(defaultVal) {\n    const geoBuf = this.readBufferLengthEncoded();\n    if (geoBuf === null || geoBuf.length === 0) {\n      return defaultVal;\n    }\n    let geoPos = 4;\n    return readGeometryObject(false);\n    function parseCoordinates(byteOrder) {\n      geoPos += 16;\n      const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n      const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n      return [x, y];\n    }\n    function readGeometryObject(inner) {\n      const byteOrder = geoBuf[geoPos++];\n      const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      switch (wkbType) {\n        case 1:\n          //wkbPoint\n          const coords = parseCoordinates(byteOrder);\n          if (inner) return coords;\n          return {\n            type: 'Point',\n            coordinates: coords\n          };\n        case 2:\n          //wkbLineString\n          const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          let coordinates = [];\n          for (let i = 0; i < pointNumber; i++) {\n            coordinates.push(parseCoordinates(byteOrder));\n          }\n          if (inner) return coordinates;\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n        case 3:\n          //wkbPolygon\n          let polygonCoordinates = [];\n          const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          for (let ring = 0; ring < numRings; ring++) {\n            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            let linesCoordinates = [];\n            for (let i = 0; i < pointNumber; i++) {\n              linesCoordinates.push(parseCoordinates(byteOrder));\n            }\n            polygonCoordinates.push(linesCoordinates);\n          }\n          if (inner) return polygonCoordinates;\n          return {\n            type: 'Polygon',\n            coordinates: polygonCoordinates\n          };\n        case 4:\n          //wkbMultiPoint\n          return {\n            type: 'MultiPoint',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 5:\n          //wkbMultiLineString\n          return {\n            type: 'MultiLineString',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 6:\n          //wkbMultiPolygon\n          return {\n            type: 'MultiPolygon',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 7:\n          //wkbGeometryCollection\n          return {\n            type: 'GeometryCollection',\n            geometries: parseGeomArray(byteOrder, false)\n          };\n      }\n      return null;\n    }\n    function parseGeomArray(byteOrder, inner) {\n      let coordinates = [];\n      const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      for (let i = 0; i < number; i++) {\n        coordinates.push(readGeometryObject(inner));\n      }\n      return coordinates;\n    }\n  }\n  peek() {\n    return this.buf[this.pos];\n  }\n  remaining() {\n    return this.end - this.pos > 0;\n  }\n  readInt8() {\n    const val = this.buf[this.pos++];\n    return val | (val & 2 ** 7) * 0x1fffffe;\n  }\n  readUInt8() {\n    return this.buf[this.pos++];\n  }\n  readInt16() {\n    const first = this.buf[this.pos++];\n    const last = this.buf[this.pos++];\n    const val = first + last * 2 ** 8;\n    return val | (val & 2 ** 15) * 0x1fffe;\n  }\n  readUInt16() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n  }\n  readInt24() {\n    const first = this.buf[this.pos];\n    const last = this.buf[this.pos + 2];\n    const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;\n    this.pos += 3;\n    return val | (val & 2 ** 23) * 0x1fe;\n  }\n  readUInt24() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n  }\n  readUInt32() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + this.buf[this.pos++] * 2 ** 24;\n  }\n  readInt32() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + (this.buf[this.pos++] << 24);\n  }\n  readBigInt64() {\n    const val = this.buf.readBigInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n  readBigUInt64() {\n    const val = this.buf.readBigUInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n  readUnsignedLength() {\n    const type = this.buf[this.pos++] & 0xff;\n    if (type < 0xfb) return type;\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this.readUInt16();\n      case 0xfd:\n        return this.readUInt24();\n      case 0xfe:\n        // limitation to BigInt signed value\n        return Number(this.readBigInt64());\n    }\n  }\n  readBuffer(len) {\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n  readBufferRemaining() {\n    let b = this.buf.subarray(this.pos, this.end);\n    this.pos = this.end;\n    return b;\n  }\n  readBufferLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n  readStringNullEnded() {\n    let initialPosition = this.pos;\n    let cnt = 0;\n    while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n      cnt++;\n    }\n    return this.buf.toString(undefined, initialPosition, initialPosition + cnt);\n  }\n  readSignedLengthBigInt() {\n    const type = this.buf[this.pos++];\n    switch (type) {\n      // null test is not used for now, since only used for reading insertId\n      // case 0xfb:\n      //   return null;\n      case 0xfc:\n        return BigInt(this.readUInt16());\n      case 0xfd:\n        return BigInt(this.readUInt24());\n      case 0xfe:\n        return this.readBigInt64();\n      default:\n        return BigInt(type);\n    }\n  }\n  readAsciiStringLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  readStringLengthEncoded() {\n    throw new Error('code is normally superseded by Node encoder or Iconv depending on charset used');\n  }\n  readBigIntLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    return this.readBigIntFromLen(len);\n  }\n  readBigIntFromLen(len) {\n    // fast-path: if length encoded is < to 16, value is in safe integer range\n    // atoi\n    if (len < 16) {\n      return BigInt(this._atoi(len));\n    }\n\n    // atoll\n    let result = 0n;\n    let negate = false;\n    let begin = this.pos;\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10n + BigInt(this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1n * result : result;\n  }\n  readDecimalLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  readDate() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    let res = [];\n    let value = 0;\n    let initPos = this.pos;\n    this.pos += len;\n    while (initPos < this.pos) {\n      const char = this.buf[initPos++];\n      if (char === 45) {\n        //minus separator\n        res.push(value);\n        value = 0;\n      } else {\n        value = value * 10 + char - 48;\n      }\n    }\n    res.push(value);\n\n    //handle zero-date as null\n    if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n    return new Date(res[0], res[1] - 1, res[2]);\n  }\n  readBinaryDate(opts) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8() - 1;\n        if (len > 3) {\n          day = this.readUInt8();\n        }\n      }\n    }\n    if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? '0000-00-00' : null;\n    if (opts.dateStrings) {\n      return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;\n    }\n    //handle zero-date as null\n    return new Date(year, month, day);\n  }\n  readDateTime() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    const str = this.buf.toString('ascii', this.pos - len, this.pos);\n    if (str.startsWith('0000-00-00 00:00:00')) return null;\n    return new Date(str);\n  }\n  readBinaryDateTime() {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;\n    return new Date(year, month - 1, day, hour, min, sec, microSec / 1000);\n  }\n  readBinaryDateTimeAsString(scale) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return '0000-00-00 00:00:00' + (scale > 0 ? '.000000'.substring(0, scale + 1) : '');\n    return appendZero(year, 4) + '-' + appendZero(month, 2) + '-' + appendZero(day, 2) + ' ' + appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2) + (microSec > 0 ? scale > 0 ? '.' + appendZero(microSec, 6).substring(0, scale) : '.' + appendZero(microSec, 6) : scale > 0 ? '.' + appendZero(microSec, 6).substring(0, scale) : '');\n  }\n  readBinaryTime() {\n    const len = this.buf[this.pos++];\n    const negate = this.buf[this.pos++] === 1;\n    const hour = this.readUInt32() * 24 + this.readUInt8();\n    const min = this.readUInt8();\n    const sec = this.readUInt8();\n    let microSec = 0;\n    if (len > 8) {\n      microSec = this.readUInt32();\n    }\n    let val = appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2);\n    if (microSec > 0) {\n      val += '.' + appendZero(microSec, 6);\n    }\n    if (negate) return '-' + val;\n    return val;\n  }\n  readFloat() {\n    const val = this.buf.readFloatLE(this.pos);\n    this.pos += 4;\n    return val;\n  }\n  readDouble() {\n    const val = this.buf.readDoubleLE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n  readIntLengthEncoded() {\n    const len = this.buf[this.pos++] & 0xff;\n    if (len < 0xfb) return this._atoi(len);\n    switch (len) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this._atoi(this.readUInt16());\n      case 0xfd:\n        return this._atoi(this.readUInt24());\n      case 0xfe:\n        // limitation to BigInt signed value\n        return this._atoi(Number(this.readBigInt64()));\n    }\n  }\n  _atoi(len) {\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1 * result : result;\n  }\n  readFloatLengthCoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return +this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n  skipLengthCodedNumber() {\n    const type = this.buf[this.pos++] & 0xff;\n    switch (type) {\n      case 251:\n        return;\n      case 252:\n        this.pos += 2 + (0xffff & (this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8));\n        return;\n      case 253:\n        this.pos += 3 + (0xffffff & (this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8) + ((this.buf[this.pos + 2] & 0xff) << 16));\n        return;\n      case 254:\n        this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));\n        return;\n      default:\n        this.pos += type;\n        return;\n    }\n  }\n  length() {\n    return this.end - this.pos;\n  }\n  subPacketLengthEncoded(len) {\n    this.skip(len);\n    return new Packet().update(this.buf, this.pos - len, this.pos);\n  }\n\n  /**\n   * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n   *\n   * @param info              current connection info\n   * @param sql               command sql\n   * @param stack             additional stack trace\n   * @returns {Error}\n   */\n  readError(info, sql, stack) {\n    this.skip(1);\n    let errno = this.readUInt16();\n    let sqlState;\n    let msg;\n    // check '#'\n    if (this.peek() === 0x23) {\n      // skip '#'\n      this.skip(6);\n      sqlState = this.buf.toString(undefined, this.pos - 5, this.pos);\n      msg = this.readStringNullEnded();\n    } else {\n      // pre 4.1 format\n      sqlState = 'HY000';\n      msg = this.buf.toString(undefined, this.pos, this.end);\n    }\n    let fatal = sqlState.startsWith('08') || sqlState === '70100';\n    return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);\n  }\n}\nconst appendZero = (val, len) => {\n  let st = val.toString();\n  while (st.length < len) {\n    st = '0' + st;\n  }\n  return st;\n};\nmodule.exports = Packet;","map":{"version":3,"names":["Errors","require","Packet","update","buf","pos","end","skip","n","readGeometry","defaultVal","geoBuf","readBufferLengthEncoded","length","geoPos","readGeometryObject","parseCoordinates","byteOrder","x","readDoubleLE","readDoubleBE","y","inner","wkbType","readInt32LE","readInt32BE","coords","type","coordinates","pointNumber","i","push","polygonCoordinates","numRings","ring","linesCoordinates","parseGeomArray","geometries","number","peek","remaining","readInt8","val","readUInt8","readInt16","first","last","readUInt16","readInt24","readUInt24","readUInt32","readInt32","readBigInt64","readBigInt64LE","readBigUInt64","readBigUInt64LE","readUnsignedLength","Number","readBuffer","len","subarray","readBufferRemaining","b","readStringNullEnded","initialPosition","cnt","toString","undefined","readSignedLengthBigInt","BigInt","readAsciiStringLengthEncoded","readStringLengthEncoded","Error","readBigIntLengthEncoded","readBigIntFromLen","_atoi","result","negate","begin","readDecimalLengthEncoded","readDate","res","value","initPos","char","Date","readBinaryDate","opts","year","month","day","dateStrings","appendZero","readDateTime","str","startsWith","readBinaryDateTime","hour","min","sec","microSec","readBinaryDateTimeAsString","scale","substring","readBinaryTime","readFloat","readFloatLE","readDouble","readIntLengthEncoded","readFloatLengthCoded","skipLengthCodedNumber","subPacketLengthEncoded","readError","info","sql","stack","errno","sqlState","msg","fatal","createError","st","module","exports"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/io/packet.js"],"sourcesContent":["'use strict';\n\nconst Errors = require('../misc/errors');\n\n/**\n * Object to easily parse buffer.\n * Packet are MUTABLE (buffer are changed, to avoid massive packet object creation).\n * Use clone() in case immutability is required\n *\n */\nclass Packet {\n  update(buf, pos, end) {\n    this.buf = buf;\n    this.pos = pos;\n    this.end = end;\n    return this;\n  }\n\n  skip(n) {\n    this.pos += n;\n  }\n\n  readGeometry(defaultVal) {\n    const geoBuf = this.readBufferLengthEncoded();\n    if (geoBuf === null || geoBuf.length === 0) {\n      return defaultVal;\n    }\n    let geoPos = 4;\n    return readGeometryObject(false);\n\n    function parseCoordinates(byteOrder) {\n      geoPos += 16;\n      const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);\n      const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);\n      return [x, y];\n    }\n\n    function readGeometryObject(inner) {\n      const byteOrder = geoBuf[geoPos++];\n      const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      switch (wkbType) {\n        case 1: //wkbPoint\n          const coords = parseCoordinates(byteOrder);\n\n          if (inner) return coords;\n          return {\n            type: 'Point',\n            coordinates: coords\n          };\n\n        case 2: //wkbLineString\n          const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          let coordinates = [];\n          for (let i = 0; i < pointNumber; i++) {\n            coordinates.push(parseCoordinates(byteOrder));\n          }\n          if (inner) return coordinates;\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n\n        case 3: //wkbPolygon\n          let polygonCoordinates = [];\n          const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n          geoPos += 4;\n          for (let ring = 0; ring < numRings; ring++) {\n            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n            geoPos += 4;\n            let linesCoordinates = [];\n            for (let i = 0; i < pointNumber; i++) {\n              linesCoordinates.push(parseCoordinates(byteOrder));\n            }\n            polygonCoordinates.push(linesCoordinates);\n          }\n\n          if (inner) return polygonCoordinates;\n          return {\n            type: 'Polygon',\n            coordinates: polygonCoordinates\n          };\n\n        case 4: //wkbMultiPoint\n          return {\n            type: 'MultiPoint',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n\n        case 5: //wkbMultiLineString\n          return {\n            type: 'MultiLineString',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 6: //wkbMultiPolygon\n          return {\n            type: 'MultiPolygon',\n            coordinates: parseGeomArray(byteOrder, true)\n          };\n        case 7: //wkbGeometryCollection\n          return {\n            type: 'GeometryCollection',\n            geometries: parseGeomArray(byteOrder, false)\n          };\n      }\n      return null;\n    }\n\n    function parseGeomArray(byteOrder, inner) {\n      let coordinates = [];\n      const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);\n      geoPos += 4;\n      for (let i = 0; i < number; i++) {\n        coordinates.push(readGeometryObject(inner));\n      }\n      return coordinates;\n    }\n  }\n\n  peek() {\n    return this.buf[this.pos];\n  }\n\n  remaining() {\n    return this.end - this.pos > 0;\n  }\n\n  readInt8() {\n    const val = this.buf[this.pos++];\n    return val | ((val & (2 ** 7)) * 0x1fffffe);\n  }\n\n  readUInt8() {\n    return this.buf[this.pos++];\n  }\n\n  readInt16() {\n    const first = this.buf[this.pos++];\n    const last = this.buf[this.pos++];\n    const val = first + last * 2 ** 8;\n    return val | ((val & (2 ** 15)) * 0x1fffe);\n  }\n\n  readUInt16() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;\n  }\n\n  readInt24() {\n    const first = this.buf[this.pos];\n    const last = this.buf[this.pos + 2];\n    const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;\n    this.pos += 3;\n    return val | ((val & (2 ** 23)) * 0x1fe);\n  }\n\n  readUInt24() {\n    return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;\n  }\n\n  readUInt32() {\n    return (\n      this.buf[this.pos++] +\n      this.buf[this.pos++] * 2 ** 8 +\n      this.buf[this.pos++] * 2 ** 16 +\n      this.buf[this.pos++] * 2 ** 24\n    );\n  }\n\n  readInt32() {\n    return (\n      this.buf[this.pos++] +\n      this.buf[this.pos++] * 2 ** 8 +\n      this.buf[this.pos++] * 2 ** 16 +\n      (this.buf[this.pos++] << 24)\n    );\n  }\n\n  readBigInt64() {\n    const val = this.buf.readBigInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  readBigUInt64() {\n    const val = this.buf.readBigUInt64LE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  readUnsignedLength() {\n    const type = this.buf[this.pos++] & 0xff;\n    if (type < 0xfb) return type;\n    switch (type) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this.readUInt16();\n      case 0xfd:\n        return this.readUInt24();\n      case 0xfe:\n        // limitation to BigInt signed value\n        return Number(this.readBigInt64());\n    }\n  }\n\n  readBuffer(len) {\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n\n  readBufferRemaining() {\n    let b = this.buf.subarray(this.pos, this.end);\n    this.pos = this.end;\n    return b;\n  }\n\n  readBufferLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.subarray(this.pos - len, this.pos);\n  }\n\n  readStringNullEnded() {\n    let initialPosition = this.pos;\n    let cnt = 0;\n    while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {\n      cnt++;\n    }\n    return this.buf.toString(undefined, initialPosition, initialPosition + cnt);\n  }\n\n  readSignedLengthBigInt() {\n    const type = this.buf[this.pos++];\n    switch (type) {\n      // null test is not used for now, since only used for reading insertId\n      // case 0xfb:\n      //   return null;\n      case 0xfc:\n        return BigInt(this.readUInt16());\n      case 0xfd:\n        return BigInt(this.readUInt24());\n      case 0xfe:\n        return this.readBigInt64();\n      default:\n        return BigInt(type);\n    }\n  }\n\n  readAsciiStringLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  readStringLengthEncoded() {\n    throw new Error('code is normally superseded by Node encoder or Iconv depending on charset used');\n  }\n\n  readBigIntLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    return this.readBigIntFromLen(len);\n  }\n\n  readBigIntFromLen(len) {\n    // fast-path: if length encoded is < to 16, value is in safe integer range\n    // atoi\n    if (len < 16) {\n      return BigInt(this._atoi(len));\n    }\n\n    // atoll\n    let result = 0n;\n    let negate = false;\n    let begin = this.pos;\n\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10n + BigInt(this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1n * result : result;\n  }\n\n  readDecimalLengthEncoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  readDate() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n\n    let res = [];\n    let value = 0;\n    let initPos = this.pos;\n    this.pos += len;\n    while (initPos < this.pos) {\n      const char = this.buf[initPos++];\n      if (char === 45) {\n        //minus separator\n        res.push(value);\n        value = 0;\n      } else {\n        value = value * 10 + char - 48;\n      }\n    }\n    res.push(value);\n\n    //handle zero-date as null\n    if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;\n\n    return new Date(res[0], res[1] - 1, res[2]);\n  }\n\n  readBinaryDate(opts) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8() - 1;\n        if (len > 3) {\n          day = this.readUInt8();\n        }\n      }\n    }\n    if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? '0000-00-00' : null;\n    if (opts.dateStrings) {\n      return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;\n    }\n    //handle zero-date as null\n    return new Date(year, month, day);\n  }\n\n  readDateTime() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    const str = this.buf.toString('ascii', this.pos - len, this.pos);\n    if (str.startsWith('0000-00-00 00:00:00')) return null;\n    return new Date(str);\n  }\n\n  readBinaryDateTime() {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;\n    return new Date(year, month - 1, day, hour, min, sec, microSec / 1000);\n  }\n\n  readBinaryDateTimeAsString(scale) {\n    const len = this.buf[this.pos++];\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let hour = 0;\n    let min = 0;\n    let sec = 0;\n    let microSec = 0;\n\n    if (len > 0) {\n      year = this.readInt16();\n      if (len > 2) {\n        month = this.readUInt8();\n        if (len > 3) {\n          day = this.readUInt8();\n          if (len > 4) {\n            hour = this.readUInt8();\n            min = this.readUInt8();\n            sec = this.readUInt8();\n            if (len > 7) {\n              microSec = this.readUInt32();\n            }\n          }\n        }\n      }\n    }\n\n    //handle zero-date as null\n    if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0)\n      return '0000-00-00 00:00:00' + (scale > 0 ? '.000000'.substring(0, scale + 1) : '');\n\n    return (\n      appendZero(year, 4) +\n      '-' +\n      appendZero(month, 2) +\n      '-' +\n      appendZero(day, 2) +\n      ' ' +\n      appendZero(hour, 2) +\n      ':' +\n      appendZero(min, 2) +\n      ':' +\n      appendZero(sec, 2) +\n      (microSec > 0\n        ? scale > 0\n          ? '.' + appendZero(microSec, 6).substring(0, scale)\n          : '.' + appendZero(microSec, 6)\n        : scale > 0\n        ? '.' + appendZero(microSec, 6).substring(0, scale)\n        : '')\n    );\n  }\n\n  readBinaryTime() {\n    const len = this.buf[this.pos++];\n    const negate = this.buf[this.pos++] === 1;\n    const hour = this.readUInt32() * 24 + this.readUInt8();\n    const min = this.readUInt8();\n    const sec = this.readUInt8();\n    let microSec = 0;\n    if (len > 8) {\n      microSec = this.readUInt32();\n    }\n    let val = appendZero(hour, 2) + ':' + appendZero(min, 2) + ':' + appendZero(sec, 2);\n    if (microSec > 0) {\n      val += '.' + appendZero(microSec, 6);\n    }\n    if (negate) return '-' + val;\n    return val;\n  }\n\n  readFloat() {\n    const val = this.buf.readFloatLE(this.pos);\n    this.pos += 4;\n    return val;\n  }\n\n  readDouble() {\n    const val = this.buf.readDoubleLE(this.pos);\n    this.pos += 8;\n    return val;\n  }\n\n  readIntLengthEncoded() {\n    const len = this.buf[this.pos++] & 0xff;\n    if (len < 0xfb) return this._atoi(len);\n    switch (len) {\n      case 0xfb:\n        return null;\n      case 0xfc:\n        return this._atoi(this.readUInt16());\n      case 0xfd:\n        return this._atoi(this.readUInt24());\n      case 0xfe:\n        // limitation to BigInt signed value\n        return this._atoi(Number(this.readBigInt64()));\n    }\n  }\n\n  _atoi(len) {\n    let result = 0;\n    let negate = false;\n    let begin = this.pos;\n\n    if (len > 0 && this.buf[begin] === 45) {\n      //minus sign\n      negate = true;\n      begin++;\n    }\n    for (; begin < this.pos + len; begin++) {\n      result = result * 10 + (this.buf[begin] - 48);\n    }\n    this.pos += len;\n    return negate ? -1 * result : result;\n  }\n\n  readFloatLengthCoded() {\n    const len = this.readUnsignedLength();\n    if (len === null) return null;\n    this.pos += len;\n    return +this.buf.toString('ascii', this.pos - len, this.pos);\n  }\n\n  skipLengthCodedNumber() {\n    const type = this.buf[this.pos++] & 0xff;\n    switch (type) {\n      case 251:\n        return;\n      case 252:\n        this.pos += 2 + (0xffff & ((this.buf[this.pos] & 0xff) + ((this.buf[this.pos + 1] & 0xff) << 8)));\n        return;\n      case 253:\n        this.pos +=\n          3 +\n          (0xffffff &\n            ((this.buf[this.pos] & 0xff) +\n              ((this.buf[this.pos + 1] & 0xff) << 8) +\n              ((this.buf[this.pos + 2] & 0xff) << 16)));\n        return;\n      case 254:\n        this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));\n        return;\n      default:\n        this.pos += type;\n        return;\n    }\n  }\n\n  length() {\n    return this.end - this.pos;\n  }\n\n  subPacketLengthEncoded(len) {\n    this.skip(len);\n    return new Packet().update(this.buf, this.pos - len, this.pos);\n  }\n\n  /**\n   * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/\n   *\n   * @param info              current connection info\n   * @param sql               command sql\n   * @param stack             additional stack trace\n   * @returns {Error}\n   */\n  readError(info, sql, stack) {\n    this.skip(1);\n    let errno = this.readUInt16();\n    let sqlState;\n    let msg;\n    // check '#'\n    if (this.peek() === 0x23) {\n      // skip '#'\n      this.skip(6);\n      sqlState = this.buf.toString(undefined, this.pos - 5, this.pos);\n      msg = this.readStringNullEnded();\n    } else {\n      // pre 4.1 format\n      sqlState = 'HY000';\n      msg = this.buf.toString(undefined, this.pos, this.end);\n    }\n    let fatal = sqlState.startsWith('08') || sqlState === '70100';\n    return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);\n  }\n}\n\nconst appendZero = (val, len) => {\n  let st = val.toString();\n  while (st.length < len) {\n    st = '0' + st;\n  }\n  return st;\n};\n\nmodule.exports = Packet;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,gBAAgB,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACXC,MAAMA,CAACC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE;IACpB,IAAI,CAACF,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,OAAO,IAAI;EACb;EAEAC,IAAIA,CAACC,CAAC,EAAE;IACN,IAAI,CAACH,GAAG,IAAIG,CAAC;EACf;EAEAC,YAAYA,CAACC,UAAU,EAAE;IACvB,MAAMC,MAAM,GAAG,IAAI,CAACC,uBAAuB,EAAE;IAC7C,IAAID,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE;MAC1C,OAAOH,UAAU;IACnB;IACA,IAAII,MAAM,GAAG,CAAC;IACd,OAAOC,kBAAkB,CAAC,KAAK,CAAC;IAEhC,SAASC,gBAAgBA,CAACC,SAAS,EAAE;MACnCH,MAAM,IAAI,EAAE;MACZ,MAAMI,CAAC,GAAGD,SAAS,GAAGN,MAAM,CAACQ,YAAY,CAACL,MAAM,GAAG,EAAE,CAAC,GAAGH,MAAM,CAACS,YAAY,CAACN,MAAM,GAAG,EAAE,CAAC;MACzF,MAAMO,CAAC,GAAGJ,SAAS,GAAGN,MAAM,CAACQ,YAAY,CAACL,MAAM,GAAG,CAAC,CAAC,GAAGH,MAAM,CAACS,YAAY,CAACN,MAAM,GAAG,CAAC,CAAC;MACvF,OAAO,CAACI,CAAC,EAAEG,CAAC,CAAC;IACf;IAEA,SAASN,kBAAkBA,CAACO,KAAK,EAAE;MACjC,MAAML,SAAS,GAAGN,MAAM,CAACG,MAAM,EAAE,CAAC;MAClC,MAAMS,OAAO,GAAGN,SAAS,GAAGN,MAAM,CAACa,WAAW,CAACV,MAAM,CAAC,GAAGH,MAAM,CAACc,WAAW,CAACX,MAAM,CAAC;MACnFA,MAAM,IAAI,CAAC;MACX,QAAQS,OAAO;QACb,KAAK,CAAC;UAAE;UACN,MAAMG,MAAM,GAAGV,gBAAgB,CAACC,SAAS,CAAC;UAE1C,IAAIK,KAAK,EAAE,OAAOI,MAAM;UACxB,OAAO;YACLC,IAAI,EAAE,OAAO;YACbC,WAAW,EAAEF;UACf,CAAC;QAEH,KAAK,CAAC;UAAE;UACN,MAAMG,WAAW,GAAGZ,SAAS,GAAGN,MAAM,CAACa,WAAW,CAACV,MAAM,CAAC,GAAGH,MAAM,CAACc,WAAW,CAACX,MAAM,CAAC;UACvFA,MAAM,IAAI,CAAC;UACX,IAAIc,WAAW,GAAG,EAAE;UACpB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;YACpCF,WAAW,CAACG,IAAI,CAACf,gBAAgB,CAACC,SAAS,CAAC,CAAC;UAC/C;UACA,IAAIK,KAAK,EAAE,OAAOM,WAAW;UAC7B,OAAO;YACLD,IAAI,EAAE,YAAY;YAClBC,WAAW,EAAEA;UACf,CAAC;QAEH,KAAK,CAAC;UAAE;UACN,IAAII,kBAAkB,GAAG,EAAE;UAC3B,MAAMC,QAAQ,GAAGhB,SAAS,GAAGN,MAAM,CAACa,WAAW,CAACV,MAAM,CAAC,GAAGH,MAAM,CAACc,WAAW,CAACX,MAAM,CAAC;UACpFA,MAAM,IAAI,CAAC;UACX,KAAK,IAAIoB,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGD,QAAQ,EAAEC,IAAI,EAAE,EAAE;YAC1C,MAAML,WAAW,GAAGZ,SAAS,GAAGN,MAAM,CAACa,WAAW,CAACV,MAAM,CAAC,GAAGH,MAAM,CAACc,WAAW,CAACX,MAAM,CAAC;YACvFA,MAAM,IAAI,CAAC;YACX,IAAIqB,gBAAgB,GAAG,EAAE;YACzB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;cACpCK,gBAAgB,CAACJ,IAAI,CAACf,gBAAgB,CAACC,SAAS,CAAC,CAAC;YACpD;YACAe,kBAAkB,CAACD,IAAI,CAACI,gBAAgB,CAAC;UAC3C;UAEA,IAAIb,KAAK,EAAE,OAAOU,kBAAkB;UACpC,OAAO;YACLL,IAAI,EAAE,SAAS;YACfC,WAAW,EAAEI;UACf,CAAC;QAEH,KAAK,CAAC;UAAE;UACN,OAAO;YACLL,IAAI,EAAE,YAAY;YAClBC,WAAW,EAAEQ,cAAc,CAACnB,SAAS,EAAE,IAAI;UAC7C,CAAC;QAEH,KAAK,CAAC;UAAE;UACN,OAAO;YACLU,IAAI,EAAE,iBAAiB;YACvBC,WAAW,EAAEQ,cAAc,CAACnB,SAAS,EAAE,IAAI;UAC7C,CAAC;QACH,KAAK,CAAC;UAAE;UACN,OAAO;YACLU,IAAI,EAAE,cAAc;YACpBC,WAAW,EAAEQ,cAAc,CAACnB,SAAS,EAAE,IAAI;UAC7C,CAAC;QACH,KAAK,CAAC;UAAE;UACN,OAAO;YACLU,IAAI,EAAE,oBAAoB;YAC1BU,UAAU,EAAED,cAAc,CAACnB,SAAS,EAAE,KAAK;UAC7C,CAAC;MAAC;MAEN,OAAO,IAAI;IACb;IAEA,SAASmB,cAAcA,CAACnB,SAAS,EAAEK,KAAK,EAAE;MACxC,IAAIM,WAAW,GAAG,EAAE;MACpB,MAAMU,MAAM,GAAGrB,SAAS,GAAGN,MAAM,CAACa,WAAW,CAACV,MAAM,CAAC,GAAGH,MAAM,CAACc,WAAW,CAACX,MAAM,CAAC;MAClFA,MAAM,IAAI,CAAC;MACX,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,MAAM,EAAER,CAAC,EAAE,EAAE;QAC/BF,WAAW,CAACG,IAAI,CAAChB,kBAAkB,CAACO,KAAK,CAAC,CAAC;MAC7C;MACA,OAAOM,WAAW;IACpB;EACF;EAEAW,IAAIA,CAAA,EAAG;IACL,OAAO,IAAI,CAACnC,GAAG,CAAC,IAAI,CAACC,GAAG,CAAC;EAC3B;EAEAmC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAAClC,GAAG,GAAG,IAAI,CAACD,GAAG,GAAG,CAAC;EAChC;EAEAoC,QAAQA,CAAA,EAAG;IACT,MAAMC,GAAG,GAAG,IAAI,CAACtC,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAChC,OAAOqC,GAAG,GAAI,CAACA,GAAG,GAAI,CAAC,IAAI,CAAE,IAAI,SAAU;EAC7C;EAEAC,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACvC,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;EAC7B;EAEAuC,SAASA,CAAA,EAAG;IACV,MAAMC,KAAK,GAAG,IAAI,CAACzC,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAClC,MAAMyC,IAAI,GAAG,IAAI,CAAC1C,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IACjC,MAAMqC,GAAG,GAAGG,KAAK,GAAGC,IAAI,GAAG,CAAC,IAAI,CAAC;IACjC,OAAOJ,GAAG,GAAI,CAACA,GAAG,GAAI,CAAC,IAAI,EAAG,IAAI,OAAQ;EAC5C;EAEAK,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC3C,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC;EAC7D;EAEA2C,SAASA,CAAA,EAAG;IACV,MAAMH,KAAK,GAAG,IAAI,CAACzC,GAAG,CAAC,IAAI,CAACC,GAAG,CAAC;IAChC,MAAMyC,IAAI,GAAG,IAAI,CAAC1C,GAAG,CAAC,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC;IACnC,MAAMqC,GAAG,GAAGG,KAAK,GAAG,IAAI,CAACzC,GAAG,CAAC,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAGyC,IAAI,GAAG,CAAC,IAAI,EAAE;IACpE,IAAI,CAACzC,GAAG,IAAI,CAAC;IACb,OAAOqC,GAAG,GAAI,CAACA,GAAG,GAAI,CAAC,IAAI,EAAG,IAAI,KAAM;EAC1C;EAEAO,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC7C,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE;EAC9F;EAEA6C,UAAUA,CAAA,EAAG;IACX,OACE,IAAI,CAAC9C,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GACpB,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAC7B,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE,GAC9B,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE;EAElC;EAEA8C,SAASA,CAAA,EAAG;IACV,OACE,IAAI,CAAC/C,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GACpB,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAC7B,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE,IAC7B,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;EAEhC;EAEA+C,YAAYA,CAAA,EAAG;IACb,MAAMV,GAAG,GAAG,IAAI,CAACtC,GAAG,CAACiD,cAAc,CAAC,IAAI,CAAChD,GAAG,CAAC;IAC7C,IAAI,CAACA,GAAG,IAAI,CAAC;IACb,OAAOqC,GAAG;EACZ;EAEAY,aAAaA,CAAA,EAAG;IACd,MAAMZ,GAAG,GAAG,IAAI,CAACtC,GAAG,CAACmD,eAAe,CAAC,IAAI,CAAClD,GAAG,CAAC;IAC9C,IAAI,CAACA,GAAG,IAAI,CAAC;IACb,OAAOqC,GAAG;EACZ;EAEAc,kBAAkBA,CAAA,EAAG;IACnB,MAAM7B,IAAI,GAAG,IAAI,CAACvB,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,IAAI;IACxC,IAAIsB,IAAI,GAAG,IAAI,EAAE,OAAOA,IAAI;IAC5B,QAAQA,IAAI;MACV,KAAK,IAAI;QACP,OAAO,IAAI;MACb,KAAK,IAAI;QACP,OAAO,IAAI,CAACoB,UAAU,EAAE;MAC1B,KAAK,IAAI;QACP,OAAO,IAAI,CAACE,UAAU,EAAE;MAC1B,KAAK,IAAI;QACP;QACA,OAAOQ,MAAM,CAAC,IAAI,CAACL,YAAY,EAAE,CAAC;IAAC;EAEzC;EAEAM,UAAUA,CAACC,GAAG,EAAE;IACd,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,OAAO,IAAI,CAACvD,GAAG,CAACwD,QAAQ,CAAC,IAAI,CAACvD,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EACpD;EAEAwD,mBAAmBA,CAAA,EAAG;IACpB,IAAIC,CAAC,GAAG,IAAI,CAAC1D,GAAG,CAACwD,QAAQ,CAAC,IAAI,CAACvD,GAAG,EAAE,IAAI,CAACC,GAAG,CAAC;IAC7C,IAAI,CAACD,GAAG,GAAG,IAAI,CAACC,GAAG;IACnB,OAAOwD,CAAC;EACV;EAEAlD,uBAAuBA,CAAA,EAAG;IACxB,MAAM+C,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,OAAO,IAAI,CAACvD,GAAG,CAACwD,QAAQ,CAAC,IAAI,CAACvD,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EACpD;EAEA0D,mBAAmBA,CAAA,EAAG;IACpB,IAAIC,eAAe,GAAG,IAAI,CAAC3D,GAAG;IAC9B,IAAI4D,GAAG,GAAG,CAAC;IACX,OAAO,IAAI,CAACzB,SAAS,EAAE,GAAG,CAAC,IAAI,IAAI,CAACpC,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,KAAK,CAAC,EAAE;MACzD4D,GAAG,EAAE;IACP;IACA,OAAO,IAAI,CAAC7D,GAAG,CAAC8D,QAAQ,CAACC,SAAS,EAAEH,eAAe,EAAEA,eAAe,GAAGC,GAAG,CAAC;EAC7E;EAEAG,sBAAsBA,CAAA,EAAG;IACvB,MAAMzC,IAAI,GAAG,IAAI,CAACvB,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IACjC,QAAQsB,IAAI;MACV;MACA;MACA;MACA,KAAK,IAAI;QACP,OAAO0C,MAAM,CAAC,IAAI,CAACtB,UAAU,EAAE,CAAC;MAClC,KAAK,IAAI;QACP,OAAOsB,MAAM,CAAC,IAAI,CAACpB,UAAU,EAAE,CAAC;MAClC,KAAK,IAAI;QACP,OAAO,IAAI,CAACG,YAAY,EAAE;MAC5B;QACE,OAAOiB,MAAM,CAAC1C,IAAI,CAAC;IAAC;EAE1B;EAEA2C,4BAA4BA,CAAA,EAAG;IAC7B,MAAMX,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,OAAO,IAAI,CAACvD,GAAG,CAAC8D,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC7D,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EAC7D;EAEAkE,uBAAuBA,CAAA,EAAG;IACxB,MAAM,IAAIC,KAAK,CAAC,gFAAgF,CAAC;EACnG;EAEAC,uBAAuBA,CAAA,EAAG;IACxB,MAAMd,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,OAAO,IAAI,CAACe,iBAAiB,CAACf,GAAG,CAAC;EACpC;EAEAe,iBAAiBA,CAACf,GAAG,EAAE;IACrB;IACA;IACA,IAAIA,GAAG,GAAG,EAAE,EAAE;MACZ,OAAOU,MAAM,CAAC,IAAI,CAACM,KAAK,CAAChB,GAAG,CAAC,CAAC;IAChC;;IAEA;IACA,IAAIiB,MAAM,GAAG,EAAE;IACf,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAIC,KAAK,GAAG,IAAI,CAACzE,GAAG;IAEpB,IAAIsD,GAAG,GAAG,CAAC,IAAI,IAAI,CAACvD,GAAG,CAAC0E,KAAK,CAAC,KAAK,EAAE,EAAE;MACrC;MACAD,MAAM,GAAG,IAAI;MACbC,KAAK,EAAE;IACT;IACA,OAAOA,KAAK,GAAG,IAAI,CAACzE,GAAG,GAAGsD,GAAG,EAAEmB,KAAK,EAAE,EAAE;MACtCF,MAAM,GAAGA,MAAM,GAAG,GAAG,GAAGP,MAAM,CAAC,IAAI,CAACjE,GAAG,CAAC0E,KAAK,CAAC,GAAG,EAAE,CAAC;IACtD;IACA,IAAI,CAACzE,GAAG,IAAIsD,GAAG;IACf,OAAOkB,MAAM,GAAG,CAAC,EAAE,GAAGD,MAAM,GAAGA,MAAM;EACvC;EAEAG,wBAAwBA,CAAA,EAAG;IACzB,MAAMpB,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,OAAO,IAAI,CAACvD,GAAG,CAAC8D,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC7D,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EAC7D;EAEA2E,QAAQA,CAAA,EAAG;IACT,MAAMrB,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAE7B,IAAIsB,GAAG,GAAG,EAAE;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,OAAO,GAAG,IAAI,CAAC9E,GAAG;IACtB,IAAI,CAACA,GAAG,IAAIsD,GAAG;IACf,OAAOwB,OAAO,GAAG,IAAI,CAAC9E,GAAG,EAAE;MACzB,MAAM+E,IAAI,GAAG,IAAI,CAAChF,GAAG,CAAC+E,OAAO,EAAE,CAAC;MAChC,IAAIC,IAAI,KAAK,EAAE,EAAE;QACf;QACAH,GAAG,CAAClD,IAAI,CAACmD,KAAK,CAAC;QACfA,KAAK,GAAG,CAAC;MACX,CAAC,MAAM;QACLA,KAAK,GAAGA,KAAK,GAAG,EAAE,GAAGE,IAAI,GAAG,EAAE;MAChC;IACF;IACAH,GAAG,CAAClD,IAAI,CAACmD,KAAK,CAAC;;IAEf;IACA,IAAID,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI;IAE7D,OAAO,IAAII,IAAI,CAACJ,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;EAC7C;EAEAK,cAAcA,CAACC,IAAI,EAAE;IACnB,MAAM5B,GAAG,GAAG,IAAI,CAACvD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAChC,IAAImF,IAAI,GAAG,CAAC;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAG,CAAC;IACX,IAAI/B,GAAG,GAAG,CAAC,EAAE;MACX6B,IAAI,GAAG,IAAI,CAAC5C,SAAS,EAAE;MACvB,IAAIe,GAAG,GAAG,CAAC,EAAE;QACX8B,KAAK,GAAG,IAAI,CAAC9C,SAAS,EAAE,GAAG,CAAC;QAC5B,IAAIgB,GAAG,GAAG,CAAC,EAAE;UACX+B,GAAG,GAAG,IAAI,CAAC/C,SAAS,EAAE;QACxB;MACF;IACF;IACA,IAAI6C,IAAI,KAAK,CAAC,IAAIC,KAAK,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,EAAE,OAAOH,IAAI,CAACI,WAAW,GAAG,YAAY,GAAG,IAAI;IACzF,IAAIJ,IAAI,CAACI,WAAW,EAAE;MACpB,OAAQ,GAAEC,UAAU,CAACJ,IAAI,EAAE,CAAC,CAAE,IAAGI,UAAU,CAACH,KAAK,GAAG,CAAC,EAAE,CAAC,CAAE,IAAGG,UAAU,CAACF,GAAG,EAAE,CAAC,CAAE,EAAC;IACnF;IACA;IACA,OAAO,IAAIL,IAAI,CAACG,IAAI,EAAEC,KAAK,EAAEC,GAAG,CAAC;EACnC;EAEAG,YAAYA,CAAA,EAAG;IACb,MAAMlC,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,MAAMmC,GAAG,GAAG,IAAI,CAAC1F,GAAG,CAAC8D,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC7D,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;IAChE,IAAIyF,GAAG,CAACC,UAAU,CAAC,qBAAqB,CAAC,EAAE,OAAO,IAAI;IACtD,OAAO,IAAIV,IAAI,CAACS,GAAG,CAAC;EACtB;EAEAE,kBAAkBA,CAAA,EAAG;IACnB,MAAMrC,GAAG,GAAG,IAAI,CAACvD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAChC,IAAImF,IAAI,GAAG,CAAC;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIO,IAAI,GAAG,CAAC;IACZ,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,QAAQ,GAAG,CAAC;IAEhB,IAAIzC,GAAG,GAAG,CAAC,EAAE;MACX6B,IAAI,GAAG,IAAI,CAAC5C,SAAS,EAAE;MACvB,IAAIe,GAAG,GAAG,CAAC,EAAE;QACX8B,KAAK,GAAG,IAAI,CAAC9C,SAAS,EAAE;QACxB,IAAIgB,GAAG,GAAG,CAAC,EAAE;UACX+B,GAAG,GAAG,IAAI,CAAC/C,SAAS,EAAE;UACtB,IAAIgB,GAAG,GAAG,CAAC,EAAE;YACXsC,IAAI,GAAG,IAAI,CAACtD,SAAS,EAAE;YACvBuD,GAAG,GAAG,IAAI,CAACvD,SAAS,EAAE;YACtBwD,GAAG,GAAG,IAAI,CAACxD,SAAS,EAAE;YACtB,IAAIgB,GAAG,GAAG,CAAC,EAAE;cACXyC,QAAQ,GAAG,IAAI,CAAClD,UAAU,EAAE;YAC9B;UACF;QACF;MACF;IACF;;IAEA;IACA,IAAIsC,IAAI,KAAK,CAAC,IAAIC,KAAK,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIO,IAAI,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIC,QAAQ,KAAK,CAAC,EAAE,OAAO,IAAI;IACjH,OAAO,IAAIf,IAAI,CAACG,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAEC,GAAG,EAAEO,IAAI,EAAEC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,GAAG,IAAI,CAAC;EACxE;EAEAC,0BAA0BA,CAACC,KAAK,EAAE;IAChC,MAAM3C,GAAG,GAAG,IAAI,CAACvD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAChC,IAAImF,IAAI,GAAG,CAAC;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIO,IAAI,GAAG,CAAC;IACZ,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,QAAQ,GAAG,CAAC;IAEhB,IAAIzC,GAAG,GAAG,CAAC,EAAE;MACX6B,IAAI,GAAG,IAAI,CAAC5C,SAAS,EAAE;MACvB,IAAIe,GAAG,GAAG,CAAC,EAAE;QACX8B,KAAK,GAAG,IAAI,CAAC9C,SAAS,EAAE;QACxB,IAAIgB,GAAG,GAAG,CAAC,EAAE;UACX+B,GAAG,GAAG,IAAI,CAAC/C,SAAS,EAAE;UACtB,IAAIgB,GAAG,GAAG,CAAC,EAAE;YACXsC,IAAI,GAAG,IAAI,CAACtD,SAAS,EAAE;YACvBuD,GAAG,GAAG,IAAI,CAACvD,SAAS,EAAE;YACtBwD,GAAG,GAAG,IAAI,CAACxD,SAAS,EAAE;YACtB,IAAIgB,GAAG,GAAG,CAAC,EAAE;cACXyC,QAAQ,GAAG,IAAI,CAAClD,UAAU,EAAE;YAC9B;UACF;QACF;MACF;IACF;;IAEA;IACA,IAAIsC,IAAI,KAAK,CAAC,IAAIC,KAAK,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIO,IAAI,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,IAAIC,QAAQ,KAAK,CAAC,EAClG,OAAO,qBAAqB,IAAIE,KAAK,GAAG,CAAC,GAAG,SAAS,CAACC,SAAS,CAAC,CAAC,EAAED,KAAK,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;IAErF,OACEV,UAAU,CAACJ,IAAI,EAAE,CAAC,CAAC,GACnB,GAAG,GACHI,UAAU,CAACH,KAAK,EAAE,CAAC,CAAC,GACpB,GAAG,GACHG,UAAU,CAACF,GAAG,EAAE,CAAC,CAAC,GAClB,GAAG,GACHE,UAAU,CAACK,IAAI,EAAE,CAAC,CAAC,GACnB,GAAG,GACHL,UAAU,CAACM,GAAG,EAAE,CAAC,CAAC,GAClB,GAAG,GACHN,UAAU,CAACO,GAAG,EAAE,CAAC,CAAC,IACjBC,QAAQ,GAAG,CAAC,GACTE,KAAK,GAAG,CAAC,GACP,GAAG,GAAGV,UAAU,CAACQ,QAAQ,EAAE,CAAC,CAAC,CAACG,SAAS,CAAC,CAAC,EAAED,KAAK,CAAC,GACjD,GAAG,GAAGV,UAAU,CAACQ,QAAQ,EAAE,CAAC,CAAC,GAC/BE,KAAK,GAAG,CAAC,GACT,GAAG,GAAGV,UAAU,CAACQ,QAAQ,EAAE,CAAC,CAAC,CAACG,SAAS,CAAC,CAAC,EAAED,KAAK,CAAC,GACjD,EAAE,CAAC;EAEX;EAEAE,cAAcA,CAAA,EAAG;IACf,MAAM7C,GAAG,GAAG,IAAI,CAACvD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC;IAChC,MAAMwE,MAAM,GAAG,IAAI,CAACzE,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,KAAK,CAAC;IACzC,MAAM4F,IAAI,GAAG,IAAI,CAAC/C,UAAU,EAAE,GAAG,EAAE,GAAG,IAAI,CAACP,SAAS,EAAE;IACtD,MAAMuD,GAAG,GAAG,IAAI,CAACvD,SAAS,EAAE;IAC5B,MAAMwD,GAAG,GAAG,IAAI,CAACxD,SAAS,EAAE;IAC5B,IAAIyD,QAAQ,GAAG,CAAC;IAChB,IAAIzC,GAAG,GAAG,CAAC,EAAE;MACXyC,QAAQ,GAAG,IAAI,CAAClD,UAAU,EAAE;IAC9B;IACA,IAAIR,GAAG,GAAGkD,UAAU,CAACK,IAAI,EAAE,CAAC,CAAC,GAAG,GAAG,GAAGL,UAAU,CAACM,GAAG,EAAE,CAAC,CAAC,GAAG,GAAG,GAAGN,UAAU,CAACO,GAAG,EAAE,CAAC,CAAC;IACnF,IAAIC,QAAQ,GAAG,CAAC,EAAE;MAChB1D,GAAG,IAAI,GAAG,GAAGkD,UAAU,CAACQ,QAAQ,EAAE,CAAC,CAAC;IACtC;IACA,IAAIvB,MAAM,EAAE,OAAO,GAAG,GAAGnC,GAAG;IAC5B,OAAOA,GAAG;EACZ;EAEA+D,SAASA,CAAA,EAAG;IACV,MAAM/D,GAAG,GAAG,IAAI,CAACtC,GAAG,CAACsG,WAAW,CAAC,IAAI,CAACrG,GAAG,CAAC;IAC1C,IAAI,CAACA,GAAG,IAAI,CAAC;IACb,OAAOqC,GAAG;EACZ;EAEAiE,UAAUA,CAAA,EAAG;IACX,MAAMjE,GAAG,GAAG,IAAI,CAACtC,GAAG,CAACe,YAAY,CAAC,IAAI,CAACd,GAAG,CAAC;IAC3C,IAAI,CAACA,GAAG,IAAI,CAAC;IACb,OAAOqC,GAAG;EACZ;EAEAkE,oBAAoBA,CAAA,EAAG;IACrB,MAAMjD,GAAG,GAAG,IAAI,CAACvD,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,IAAI;IACvC,IAAIsD,GAAG,GAAG,IAAI,EAAE,OAAO,IAAI,CAACgB,KAAK,CAAChB,GAAG,CAAC;IACtC,QAAQA,GAAG;MACT,KAAK,IAAI;QACP,OAAO,IAAI;MACb,KAAK,IAAI;QACP,OAAO,IAAI,CAACgB,KAAK,CAAC,IAAI,CAAC5B,UAAU,EAAE,CAAC;MACtC,KAAK,IAAI;QACP,OAAO,IAAI,CAAC4B,KAAK,CAAC,IAAI,CAAC1B,UAAU,EAAE,CAAC;MACtC,KAAK,IAAI;QACP;QACA,OAAO,IAAI,CAAC0B,KAAK,CAAClB,MAAM,CAAC,IAAI,CAACL,YAAY,EAAE,CAAC,CAAC;IAAC;EAErD;EAEAuB,KAAKA,CAAChB,GAAG,EAAE;IACT,IAAIiB,MAAM,GAAG,CAAC;IACd,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAIC,KAAK,GAAG,IAAI,CAACzE,GAAG;IAEpB,IAAIsD,GAAG,GAAG,CAAC,IAAI,IAAI,CAACvD,GAAG,CAAC0E,KAAK,CAAC,KAAK,EAAE,EAAE;MACrC;MACAD,MAAM,GAAG,IAAI;MACbC,KAAK,EAAE;IACT;IACA,OAAOA,KAAK,GAAG,IAAI,CAACzE,GAAG,GAAGsD,GAAG,EAAEmB,KAAK,EAAE,EAAE;MACtCF,MAAM,GAAGA,MAAM,GAAG,EAAE,IAAI,IAAI,CAACxE,GAAG,CAAC0E,KAAK,CAAC,GAAG,EAAE,CAAC;IAC/C;IACA,IAAI,CAACzE,GAAG,IAAIsD,GAAG;IACf,OAAOkB,MAAM,GAAG,CAAC,CAAC,GAAGD,MAAM,GAAGA,MAAM;EACtC;EAEAiC,oBAAoBA,CAAA,EAAG;IACrB,MAAMlD,GAAG,GAAG,IAAI,CAACH,kBAAkB,EAAE;IACrC,IAAIG,GAAG,KAAK,IAAI,EAAE,OAAO,IAAI;IAC7B,IAAI,CAACtD,GAAG,IAAIsD,GAAG;IACf,OAAO,CAAC,IAAI,CAACvD,GAAG,CAAC8D,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC7D,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EAC9D;EAEAyG,qBAAqBA,CAAA,EAAG;IACtB,MAAMnF,IAAI,GAAG,IAAI,CAACvB,GAAG,CAAC,IAAI,CAACC,GAAG,EAAE,CAAC,GAAG,IAAI;IACxC,QAAQsB,IAAI;MACV,KAAK,GAAG;QACN;MACF,KAAK,GAAG;QACN,IAAI,CAACtB,GAAG,IAAI,CAAC,IAAI,MAAM,GAAI,CAAC,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,CAAE,CAAC;QACjG;MACF,KAAK,GAAG;QACN,IAAI,CAACA,GAAG,IACN,CAAC,IACA,QAAQ,GACN,CAAC,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,CAAC,GAAG,IAAI,KACxB,CAAC,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,IACrC,CAAC,IAAI,CAACD,GAAG,CAAC,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,KAAK,EAAE,CAAE,CAAC;QAC/C;MACF,KAAK,GAAG;QACN,IAAI,CAACA,GAAG,IAAI,CAAC,GAAGoD,MAAM,CAAC,IAAI,CAACrD,GAAG,CAACmD,eAAe,CAAC,IAAI,CAAClD,GAAG,CAAC,CAAC;QAC1D;MACF;QACE,IAAI,CAACA,GAAG,IAAIsB,IAAI;QAChB;IAAO;EAEb;EAEAd,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACP,GAAG,GAAG,IAAI,CAACD,GAAG;EAC5B;EAEA0G,sBAAsBA,CAACpD,GAAG,EAAE;IAC1B,IAAI,CAACpD,IAAI,CAACoD,GAAG,CAAC;IACd,OAAO,IAAIzD,MAAM,EAAE,CAACC,MAAM,CAAC,IAAI,CAACC,GAAG,EAAE,IAAI,CAACC,GAAG,GAAGsD,GAAG,EAAE,IAAI,CAACtD,GAAG,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE2G,SAASA,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAC1B,IAAI,CAAC5G,IAAI,CAAC,CAAC,CAAC;IACZ,IAAI6G,KAAK,GAAG,IAAI,CAACrE,UAAU,EAAE;IAC7B,IAAIsE,QAAQ;IACZ,IAAIC,GAAG;IACP;IACA,IAAI,IAAI,CAAC/E,IAAI,EAAE,KAAK,IAAI,EAAE;MACxB;MACA,IAAI,CAAChC,IAAI,CAAC,CAAC,CAAC;MACZ8G,QAAQ,GAAG,IAAI,CAACjH,GAAG,CAAC8D,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC9D,GAAG,GAAG,CAAC,EAAE,IAAI,CAACA,GAAG,CAAC;MAC/DiH,GAAG,GAAG,IAAI,CAACvD,mBAAmB,EAAE;IAClC,CAAC,MAAM;MACL;MACAsD,QAAQ,GAAG,OAAO;MAClBC,GAAG,GAAG,IAAI,CAAClH,GAAG,CAAC8D,QAAQ,CAACC,SAAS,EAAE,IAAI,CAAC9D,GAAG,EAAE,IAAI,CAACC,GAAG,CAAC;IACxD;IACA,IAAIiH,KAAK,GAAGF,QAAQ,CAACtB,UAAU,CAAC,IAAI,CAAC,IAAIsB,QAAQ,KAAK,OAAO;IAC7D,OAAOrH,MAAM,CAACwH,WAAW,CAACF,GAAG,EAAEF,KAAK,EAAEH,IAAI,EAAEI,QAAQ,EAAEH,GAAG,EAAEK,KAAK,EAAEJ,KAAK,CAAC;EAC1E;AACF;AAEA,MAAMvB,UAAU,GAAGA,CAAClD,GAAG,EAAEiB,GAAG,KAAK;EAC/B,IAAI8D,EAAE,GAAG/E,GAAG,CAACwB,QAAQ,EAAE;EACvB,OAAOuD,EAAE,CAAC5G,MAAM,GAAG8C,GAAG,EAAE;IACtB8D,EAAE,GAAG,GAAG,GAAGA,EAAE;EACf;EACA,OAAOA,EAAE;AACX,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAGzH,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}