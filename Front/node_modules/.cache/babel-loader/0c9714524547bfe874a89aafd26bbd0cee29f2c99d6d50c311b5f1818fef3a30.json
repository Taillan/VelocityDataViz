{"ast":null,"code":"const PluginAuth = require('./plugin-auth');\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst Errors = require('../../../misc/errors');\nconst Crypto = require('crypto');\n\n/**\n * Use Sha256 authentication\n */\nclass Sha256PasswordAuth extends PluginAuth {\n  constructor(packSeq, compressPackSeq, pluginData, cmdParam, resolve, reject, multiAuthResolver) {\n    super(cmdParam, resolve, reject, multiAuthResolver);\n    this.pluginData = pluginData;\n    this.sequenceNo = packSeq;\n    this.counter = 0;\n    this.initialState = true;\n  }\n  start(out, opts, info) {\n    this.exchange(this.pluginData, out, opts, info);\n    this.onPacketReceive = this.response;\n  }\n  exchange(buffer, out, opts, info) {\n    if (this.initialState) {\n      if (!opts.password) {\n        out.startPacket(this);\n        out.writeEmptyPacket(true);\n        return;\n      } else if (opts.ssl) {\n        // using SSL, so sending password in clear\n        out.startPacket(this);\n        if (opts.password) {\n          out.writeString(opts.password);\n        }\n        out.writeInt8(0);\n        out.flushPacket();\n        return;\n      } else {\n        // retrieve public key from configuration or from server\n        if (opts.rsaPublicKey) {\n          try {\n            let key = opts.rsaPublicKey;\n            if (!key.includes('-----BEGIN')) {\n              // rsaPublicKey contain path\n              key = fs.readFileSync(key, 'utf8');\n            }\n            this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);\n          } catch (err) {\n            return this.throwError(err, info);\n          }\n        } else {\n          if (!opts.allowPublicKeyRetrieval) {\n            return this.throwError(Errors.createFatalError('RSA public key is not available client side. Either set option `rsaPublicKey` to indicate' + ' public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`', Errors.ER_CANNOT_RETRIEVE_RSA_KEY, info), info);\n          }\n          this.initialState = false;\n\n          // ask public Key Retrieval\n          out.startPacket(this);\n          out.writeInt8(0x01);\n          out.flushPacket();\n          return;\n        }\n      }\n\n      // send Sha256Password Packet\n      Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n    } else {\n      // has request public key\n      this.publicKey = Sha256PasswordAuth.retrievePublicKey(buffer.toString('utf8', 1));\n      Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n    }\n  }\n  static retrievePublicKey(key) {\n    return key.replace('(-+BEGIN PUBLIC KEY-+\\\\r?\\\\n|\\\\n?-+END PUBLIC KEY-+\\\\r?\\\\n?)', '');\n  }\n  static sendSha256PwdPacket(cmd, pluginData, publicKey, password, out) {\n    const truncatedSeed = pluginData.slice(0, pluginData.length - 1);\n    out.startPacket(cmd);\n    const enc = Sha256PasswordAuth.encrypt(truncatedSeed, password, publicKey);\n    out.writeBuffer(enc, 0, enc.length);\n    out.flushPacket();\n  }\n  static encryptSha256Password(password, seed) {\n    if (!password) return Buffer.alloc(0);\n    let hash = Crypto.createHash('sha256');\n    let stage1 = hash.update(password, 'utf8').digest();\n    hash = Crypto.createHash('sha256');\n    let stage2 = hash.update(stage1).digest();\n    hash = Crypto.createHash('sha256');\n\n    // order is different than sha 1 !!!!!\n    hash.update(stage2);\n    hash.update(seed);\n    let digest = hash.digest();\n    let returnBytes = Buffer.allocUnsafe(digest.length);\n    for (let i = 0; i < digest.length; i++) {\n      returnBytes[i] = stage1[i] ^ digest[i];\n    }\n    return returnBytes;\n  }\n\n  // encrypt password with public key\n  static encrypt(seed, password, publicKey) {\n    const nullFinishedPwd = Buffer.from(password + '\\0');\n    const xorBytes = Buffer.allocUnsafe(nullFinishedPwd.length);\n    const seedLength = seed.length;\n    for (let i = 0; i < xorBytes.length; i++) {\n      xorBytes[i] = nullFinishedPwd[i] ^ seed[i % seedLength];\n    }\n    return crypto.publicEncrypt({\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n    }, xorBytes);\n  }\n  response(packet, out, opts, info) {\n    const marker = packet.peek();\n    switch (marker) {\n      //*********************************************************************************************************\n      //* OK_Packet and Err_Packet ending packet\n      //*********************************************************************************************************\n      case 0x00:\n      case 0xff:\n        this.emit('send_end');\n        return this.successSend(packet, out, opts, info);\n      default:\n        let promptData = packet.readBufferRemaining();\n        this.exchange(promptData, out, opts, info);\n        this.onPacketReceive = this.response;\n    }\n  }\n}\nmodule.exports = Sha256PasswordAuth;","map":{"version":3,"names":["PluginAuth","require","fs","crypto","Errors","Crypto","Sha256PasswordAuth","constructor","packSeq","compressPackSeq","pluginData","cmdParam","resolve","reject","multiAuthResolver","sequenceNo","counter","initialState","start","out","opts","info","exchange","onPacketReceive","response","buffer","password","startPacket","writeEmptyPacket","ssl","writeString","writeInt8","flushPacket","rsaPublicKey","key","includes","readFileSync","publicKey","retrievePublicKey","err","throwError","allowPublicKeyRetrieval","createFatalError","ER_CANNOT_RETRIEVE_RSA_KEY","sendSha256PwdPacket","toString","replace","cmd","truncatedSeed","slice","length","enc","encrypt","writeBuffer","encryptSha256Password","seed","Buffer","alloc","hash","createHash","stage1","update","digest","stage2","returnBytes","allocUnsafe","i","nullFinishedPwd","from","xorBytes","seedLength","publicEncrypt","padding","constants","RSA_PKCS1_OAEP_PADDING","packet","marker","peek","emit","successSend","promptData","readBufferRemaining","module","exports"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/cmd/handshake/auth/sha256-password-auth.js"],"sourcesContent":["const PluginAuth = require('./plugin-auth');\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst Errors = require('../../../misc/errors');\nconst Crypto = require('crypto');\n\n/**\n * Use Sha256 authentication\n */\nclass Sha256PasswordAuth extends PluginAuth {\n  constructor(packSeq, compressPackSeq, pluginData, cmdParam, resolve, reject, multiAuthResolver) {\n    super(cmdParam, resolve, reject, multiAuthResolver);\n    this.pluginData = pluginData;\n    this.sequenceNo = packSeq;\n    this.counter = 0;\n    this.initialState = true;\n  }\n\n  start(out, opts, info) {\n    this.exchange(this.pluginData, out, opts, info);\n    this.onPacketReceive = this.response;\n  }\n\n  exchange(buffer, out, opts, info) {\n    if (this.initialState) {\n      if (!opts.password) {\n        out.startPacket(this);\n        out.writeEmptyPacket(true);\n        return;\n      } else if (opts.ssl) {\n        // using SSL, so sending password in clear\n        out.startPacket(this);\n        if (opts.password) {\n          out.writeString(opts.password);\n        }\n        out.writeInt8(0);\n        out.flushPacket();\n        return;\n      } else {\n        // retrieve public key from configuration or from server\n        if (opts.rsaPublicKey) {\n          try {\n            let key = opts.rsaPublicKey;\n            if (!key.includes('-----BEGIN')) {\n              // rsaPublicKey contain path\n              key = fs.readFileSync(key, 'utf8');\n            }\n            this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);\n          } catch (err) {\n            return this.throwError(err, info);\n          }\n        } else {\n          if (!opts.allowPublicKeyRetrieval) {\n            return this.throwError(\n              Errors.createFatalError(\n                'RSA public key is not available client side. Either set option `rsaPublicKey` to indicate' +\n                  ' public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`',\n                Errors.ER_CANNOT_RETRIEVE_RSA_KEY,\n                info\n              ),\n              info\n            );\n          }\n          this.initialState = false;\n\n          // ask public Key Retrieval\n          out.startPacket(this);\n          out.writeInt8(0x01);\n          out.flushPacket();\n          return;\n        }\n      }\n\n      // send Sha256Password Packet\n      Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n    } else {\n      // has request public key\n      this.publicKey = Sha256PasswordAuth.retrievePublicKey(buffer.toString('utf8', 1));\n      Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);\n    }\n  }\n\n  static retrievePublicKey(key) {\n    return key.replace('(-+BEGIN PUBLIC KEY-+\\\\r?\\\\n|\\\\n?-+END PUBLIC KEY-+\\\\r?\\\\n?)', '');\n  }\n\n  static sendSha256PwdPacket(cmd, pluginData, publicKey, password, out) {\n    const truncatedSeed = pluginData.slice(0, pluginData.length - 1);\n    out.startPacket(cmd);\n    const enc = Sha256PasswordAuth.encrypt(truncatedSeed, password, publicKey);\n    out.writeBuffer(enc, 0, enc.length);\n    out.flushPacket();\n  }\n\n  static encryptSha256Password(password, seed) {\n    if (!password) return Buffer.alloc(0);\n\n    let hash = Crypto.createHash('sha256');\n    let stage1 = hash.update(password, 'utf8').digest();\n    hash = Crypto.createHash('sha256');\n\n    let stage2 = hash.update(stage1).digest();\n    hash = Crypto.createHash('sha256');\n\n    // order is different than sha 1 !!!!!\n    hash.update(stage2);\n    hash.update(seed);\n\n    let digest = hash.digest();\n    let returnBytes = Buffer.allocUnsafe(digest.length);\n    for (let i = 0; i < digest.length; i++) {\n      returnBytes[i] = stage1[i] ^ digest[i];\n    }\n    return returnBytes;\n  }\n\n  // encrypt password with public key\n  static encrypt(seed, password, publicKey) {\n    const nullFinishedPwd = Buffer.from(password + '\\0');\n    const xorBytes = Buffer.allocUnsafe(nullFinishedPwd.length);\n    const seedLength = seed.length;\n    for (let i = 0; i < xorBytes.length; i++) {\n      xorBytes[i] = nullFinishedPwd[i] ^ seed[i % seedLength];\n    }\n    return crypto.publicEncrypt({ key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING }, xorBytes);\n  }\n\n  response(packet, out, opts, info) {\n    const marker = packet.peek();\n    switch (marker) {\n      //*********************************************************************************************************\n      //* OK_Packet and Err_Packet ending packet\n      //*********************************************************************************************************\n      case 0x00:\n      case 0xff:\n        this.emit('send_end');\n        return this.successSend(packet, out, opts, info);\n\n      default:\n        let promptData = packet.readBufferRemaining();\n        this.exchange(promptData, out, opts, info);\n        this.onPacketReceive = this.response;\n    }\n  }\n}\n\nmodule.exports = Sha256PasswordAuth;\n"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC3C,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAI,CAAC;AACxB,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMG,MAAM,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAC9C,MAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAQ,CAAC;;AAEhC;AACA;AACA;AACA,MAAMK,kBAAkB,SAASN,UAAU,CAAC;EAC1CO,WAAWA,CAACC,OAAO,EAAEC,eAAe,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,MAAM,EAAEC,iBAAiB,EAAE;IAC9F,KAAK,CAACH,QAAQ,EAAEC,OAAO,EAAEC,MAAM,EAAEC,iBAAiB,CAAC;IACnD,IAAI,CAACJ,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACK,UAAU,GAAGP,OAAO;IACzB,IAAI,CAACQ,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,YAAY,GAAG,IAAI;EAC1B;EAEAC,KAAKA,CAACC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACrB,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACZ,UAAU,EAAES,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAC/C,IAAI,CAACE,eAAe,GAAG,IAAI,CAACC,QAAQ;EACtC;EAEAF,QAAQA,CAACG,MAAM,EAAEN,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAChC,IAAI,IAAI,CAACJ,YAAY,EAAE;MACrB,IAAI,CAACG,IAAI,CAACM,QAAQ,EAAE;QAClBP,GAAG,CAACQ,WAAW,CAAC,IAAI,CAAC;QACrBR,GAAG,CAACS,gBAAgB,CAAC,IAAI,CAAC;QAC1B;MACF,CAAC,MAAM,IAAIR,IAAI,CAACS,GAAG,EAAE;QACnB;QACAV,GAAG,CAACQ,WAAW,CAAC,IAAI,CAAC;QACrB,IAAIP,IAAI,CAACM,QAAQ,EAAE;UACjBP,GAAG,CAACW,WAAW,CAACV,IAAI,CAACM,QAAQ,CAAC;QAChC;QACAP,GAAG,CAACY,SAAS,CAAC,CAAC,CAAC;QAChBZ,GAAG,CAACa,WAAW,EAAE;QACjB;MACF,CAAC,MAAM;QACL;QACA,IAAIZ,IAAI,CAACa,YAAY,EAAE;UACrB,IAAI;YACF,IAAIC,GAAG,GAAGd,IAAI,CAACa,YAAY;YAC3B,IAAI,CAACC,GAAG,CAACC,QAAQ,CAAC,YAAY,CAAC,EAAE;cAC/B;cACAD,GAAG,GAAGhC,EAAE,CAACkC,YAAY,CAACF,GAAG,EAAE,MAAM,CAAC;YACpC;YACA,IAAI,CAACG,SAAS,GAAG/B,kBAAkB,CAACgC,iBAAiB,CAACJ,GAAG,CAAC;UAC5D,CAAC,CAAC,OAAOK,GAAG,EAAE;YACZ,OAAO,IAAI,CAACC,UAAU,CAACD,GAAG,EAAElB,IAAI,CAAC;UACnC;QACF,CAAC,MAAM;UACL,IAAI,CAACD,IAAI,CAACqB,uBAAuB,EAAE;YACjC,OAAO,IAAI,CAACD,UAAU,CACpBpC,MAAM,CAACsC,gBAAgB,CACrB,2FAA2F,GACzF,uFAAuF,EACzFtC,MAAM,CAACuC,0BAA0B,EACjCtB,IAAI,CACL,EACDA,IAAI,CACL;UACH;UACA,IAAI,CAACJ,YAAY,GAAG,KAAK;;UAEzB;UACAE,GAAG,CAACQ,WAAW,CAAC,IAAI,CAAC;UACrBR,GAAG,CAACY,SAAS,CAAC,IAAI,CAAC;UACnBZ,GAAG,CAACa,WAAW,EAAE;UACjB;QACF;MACF;;MAEA;MACA1B,kBAAkB,CAACsC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAClC,UAAU,EAAE,IAAI,CAAC2B,SAAS,EAAEjB,IAAI,CAACM,QAAQ,EAAEP,GAAG,CAAC;IACnG,CAAC,MAAM;MACL;MACA,IAAI,CAACkB,SAAS,GAAG/B,kBAAkB,CAACgC,iBAAiB,CAACb,MAAM,CAACoB,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;MACjFvC,kBAAkB,CAACsC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAClC,UAAU,EAAE,IAAI,CAAC2B,SAAS,EAAEjB,IAAI,CAACM,QAAQ,EAAEP,GAAG,CAAC;IACnG;EACF;EAEA,OAAOmB,iBAAiBA,CAACJ,GAAG,EAAE;IAC5B,OAAOA,GAAG,CAACY,OAAO,CAAC,8DAA8D,EAAE,EAAE,CAAC;EACxF;EAEA,OAAOF,mBAAmBA,CAACG,GAAG,EAAErC,UAAU,EAAE2B,SAAS,EAAEX,QAAQ,EAAEP,GAAG,EAAE;IACpE,MAAM6B,aAAa,GAAGtC,UAAU,CAACuC,KAAK,CAAC,CAAC,EAAEvC,UAAU,CAACwC,MAAM,GAAG,CAAC,CAAC;IAChE/B,GAAG,CAACQ,WAAW,CAACoB,GAAG,CAAC;IACpB,MAAMI,GAAG,GAAG7C,kBAAkB,CAAC8C,OAAO,CAACJ,aAAa,EAAEtB,QAAQ,EAAEW,SAAS,CAAC;IAC1ElB,GAAG,CAACkC,WAAW,CAACF,GAAG,EAAE,CAAC,EAAEA,GAAG,CAACD,MAAM,CAAC;IACnC/B,GAAG,CAACa,WAAW,EAAE;EACnB;EAEA,OAAOsB,qBAAqBA,CAAC5B,QAAQ,EAAE6B,IAAI,EAAE;IAC3C,IAAI,CAAC7B,QAAQ,EAAE,OAAO8B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAErC,IAAIC,IAAI,GAAGrD,MAAM,CAACsD,UAAU,CAAC,QAAQ,CAAC;IACtC,IAAIC,MAAM,GAAGF,IAAI,CAACG,MAAM,CAACnC,QAAQ,EAAE,MAAM,CAAC,CAACoC,MAAM,EAAE;IACnDJ,IAAI,GAAGrD,MAAM,CAACsD,UAAU,CAAC,QAAQ,CAAC;IAElC,IAAII,MAAM,GAAGL,IAAI,CAACG,MAAM,CAACD,MAAM,CAAC,CAACE,MAAM,EAAE;IACzCJ,IAAI,GAAGrD,MAAM,CAACsD,UAAU,CAAC,QAAQ,CAAC;;IAElC;IACAD,IAAI,CAACG,MAAM,CAACE,MAAM,CAAC;IACnBL,IAAI,CAACG,MAAM,CAACN,IAAI,CAAC;IAEjB,IAAIO,MAAM,GAAGJ,IAAI,CAACI,MAAM,EAAE;IAC1B,IAAIE,WAAW,GAAGR,MAAM,CAACS,WAAW,CAACH,MAAM,CAACZ,MAAM,CAAC;IACnD,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACZ,MAAM,EAAEgB,CAAC,EAAE,EAAE;MACtCF,WAAW,CAACE,CAAC,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC,GAAGJ,MAAM,CAACI,CAAC,CAAC;IACxC;IACA,OAAOF,WAAW;EACpB;;EAEA;EACA,OAAOZ,OAAOA,CAACG,IAAI,EAAE7B,QAAQ,EAAEW,SAAS,EAAE;IACxC,MAAM8B,eAAe,GAAGX,MAAM,CAACY,IAAI,CAAC1C,QAAQ,GAAG,IAAI,CAAC;IACpD,MAAM2C,QAAQ,GAAGb,MAAM,CAACS,WAAW,CAACE,eAAe,CAACjB,MAAM,CAAC;IAC3D,MAAMoB,UAAU,GAAGf,IAAI,CAACL,MAAM;IAC9B,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,QAAQ,CAACnB,MAAM,EAAEgB,CAAC,EAAE,EAAE;MACxCG,QAAQ,CAACH,CAAC,CAAC,GAAGC,eAAe,CAACD,CAAC,CAAC,GAAGX,IAAI,CAACW,CAAC,GAAGI,UAAU,CAAC;IACzD;IACA,OAAOnE,MAAM,CAACoE,aAAa,CAAC;MAAErC,GAAG,EAAEG,SAAS;MAAEmC,OAAO,EAAErE,MAAM,CAACsE,SAAS,CAACC;IAAuB,CAAC,EAAEL,QAAQ,CAAC;EAC7G;EAEA7C,QAAQA,CAACmD,MAAM,EAAExD,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAChC,MAAMuD,MAAM,GAAGD,MAAM,CAACE,IAAI,EAAE;IAC5B,QAAQD,MAAM;MACZ;MACA;MACA;MACA,KAAK,IAAI;MACT,KAAK,IAAI;QACP,IAAI,CAACE,IAAI,CAAC,UAAU,CAAC;QACrB,OAAO,IAAI,CAACC,WAAW,CAACJ,MAAM,EAAExD,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;MAElD;QACE,IAAI2D,UAAU,GAAGL,MAAM,CAACM,mBAAmB,EAAE;QAC7C,IAAI,CAAC3D,QAAQ,CAAC0D,UAAU,EAAE7D,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;QAC1C,IAAI,CAACE,eAAe,GAAG,IAAI,CAACC,QAAQ;IAAC;EAE3C;AACF;AAEA0D,MAAM,CAACC,OAAO,GAAG7E,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}