{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\nconst Queue = require('denque');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\nconst Connection = require('./connection');\nconst CommandParameter = require('./command-parameter');\nclass Pool extends EventEmitter {\n  opts;\n  #closed = false;\n  #connectionInCreation = false;\n  #errorCreatingConnection = null;\n  #idleConnections = new Queue();\n  #activeConnections = {};\n  #requests = new Queue();\n  #unusedConnectionRemoverId;\n  #requestTimeoutId;\n  #connErrorNumber = 0;\n  #initialized = false;\n  _sizeHandlerTimeout;\n  constructor(options) {\n    super();\n    this.opts = options;\n    this.on('_idle', this._requestsHandler);\n    this.on('validateSize', this._sizeHandler);\n    this._sizeHandler();\n  }\n\n  //*****************************************************************\n  // pool automatic handlers\n  //*****************************************************************\n\n  _doCreateConnection(resolve, reject, timeoutEnd) {\n    this._createConnection().then(conn => {\n      if (this.#closed) {\n        conn.forceEnd(null, () => {}, () => {});\n        reject(new Errors.createFatalError('Cannot create new connection to pool, pool closed', Errors.ER_ADD_CONNECTION_CLOSED_POOL));\n        return;\n      }\n      conn.lastUse = Date.now();\n      const nativeDestroy = conn.destroy.bind(conn);\n      const pool = this;\n      conn.destroy = function () {\n        pool._endLeak(conn);\n        delete pool.#activeConnections[conn.threadId];\n        nativeDestroy();\n        pool.emit('validateSize');\n      };\n      conn.once('error', function () {\n        let idx = 0;\n        let currConn;\n        pool._endLeak(conn);\n        delete pool.#activeConnections[conn.threadId];\n        while (currConn = pool.#idleConnections.peekAt(idx)) {\n          if (currConn === conn) {\n            pool.#idleConnections.removeOne(idx);\n            continue;\n          }\n          //since connection did have an error, other waiting connection might too\n          //forcing validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n          currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool.opts.minDelayValidation);\n          idx++;\n        }\n        setTimeout(() => {\n          if (!pool.#requests.isEmpty()) {\n            pool._sizeHandler();\n          }\n        }, 0);\n      });\n      this.#idleConnections.push(conn);\n      this.#connectionInCreation = false;\n      this.emit('_idle');\n      this.emit('connection', conn);\n      resolve(conn);\n    }).catch(err => {\n      //if timeout is reached or authentication fail return error\n      if (this.#closed || err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698) || timeoutEnd < Date.now()) {\n        err.message = err.message + this._errorMsgAddon();\n        reject(err);\n        return;\n      }\n      setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);\n    });\n  }\n  _destroy(conn) {\n    this._endLeak(conn);\n    delete this.#activeConnections[conn.threadId];\n    conn.lastUse = Date.now();\n    conn.forceEnd(null, () => {}, () => {});\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n  release(conn) {\n    // ensure releasing only once\n    if (this.#activeConnections[conn.threadId]) {\n      this._endLeak(conn);\n      this.#activeConnections[conn.threadId] = null;\n      conn.lastUse = Date.now();\n      if (this.#closed) {\n        conn.forceEnd(null, () => {}, () => {});\n      } else if (conn.isValid()) {\n        this.emit('release', conn);\n        this.#idleConnections.push(conn);\n        process.nextTick(this.emit.bind(this, '_idle'));\n      } else {\n        this.emit('validateSize');\n      }\n    }\n  }\n  _checkLeak(conn) {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(conn => {\n      conn.leaked = true;\n      console.log(`A possible connection leak on the thread ${conn.info.threadId} (the connection not returned to the pool since ${Date.now() - conn.lastUse} ms). Has the connection.release() been called ?` + this._errorMsgAddon());\n    }, this.opts.leakDetectionTimeout, conn);\n  }\n  _endLeak(conn) {\n    if (conn.leakProcess) {\n      clearTimeout(conn.leakProcess);\n      conn.leakProcess = null;\n      if (conn.leaked) {\n        console.log(`Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`);\n      }\n    }\n  }\n\n  /**\n   * Permit to remove idle connection if unused for some time.\n   */\n  _startReaping() {\n    if (!this.#unusedConnectionRemoverId && this.opts.idleTimeout > 0) {\n      this.#unusedConnectionRemoverId = setInterval(this._reaper.bind(this), 500);\n    }\n  }\n  _stopReaping() {\n    if (this.#unusedConnectionRemoverId && this.totalConnections() === 0) {\n      clearInterval(this.#unusedConnectionRemoverId);\n    }\n  }\n  _reaper() {\n    const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1000;\n    let maxRemoval = Math.max(0, this.#idleConnections.length - this.opts.minimumIdle);\n    while (maxRemoval > 0) {\n      const conn = this.#idleConnections.peek();\n      maxRemoval--;\n      if (conn && conn.lastUse < idleTimeRemoval) {\n        this.#idleConnections.shift();\n        conn.forceEnd(null, () => {}, () => {});\n        continue;\n      }\n      break;\n    }\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n  _shouldCreateMoreConnections() {\n    return !this.#connectionInCreation && this.#idleConnections.length < this.opts.minimumIdle && this.totalConnections() < this.opts.connectionLimit && !this.#closed;\n  }\n\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n  _sizeHandler() {\n    if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {\n      this.#connectionInCreation = true;\n      setImmediate(function () {\n        const timeoutEnd = Date.now() + this.opts.initializationTimeout;\n        new Promise((resolve, reject) => {\n          this._doCreateConnection(resolve, reject, timeoutEnd);\n        }).then(() => {\n          this.#initialized = true;\n          this.#errorCreatingConnection = null;\n          this.#connErrorNumber = 0;\n          if (this._shouldCreateMoreConnections()) {\n            this.emit('validateSize');\n          }\n          this._startReaping();\n        }).catch(err => {\n          this.#connectionInCreation = false;\n          if (!this.#closed) {\n            if (!this.#initialized) {\n              err.message = 'Error during pool initialization: ' + err.message;\n            } else {\n              err.message = 'Pool fails to create connection: ' + err.message;\n            }\n            this.#errorCreatingConnection = err;\n            this.emit('error', err);\n\n            //delay next try\n            this._sizeHandlerTimeout = setTimeout(function () {\n              this._sizeHandlerTimeout = null;\n              if (!this.#requests.isEmpty()) {\n                this._sizeHandler();\n              }\n            }.bind(this), Math.min(++this.#connErrorNumber * 500, 10000));\n          }\n        });\n      }.bind(this));\n    }\n  }\n\n  /**\n   * Launch next waiting task request if available connections.\n   */\n  _requestsHandler() {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    const request = this.#requests.shift();\n    if (request) {\n      const conn = this.#idleConnections.shift();\n      if (conn) {\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        this.emit('acquire', conn);\n        this.#activeConnections[conn.threadId] = conn;\n        request.resolver(conn);\n      } else {\n        this.#requests.unshift(request);\n      }\n      this._requestTimeoutHandler();\n    }\n  }\n  _hasIdleConnection() {\n    return !this.#idleConnections.isEmpty();\n  }\n\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @returns {Promise<Connection>} connection of null of no valid idle connection.\n   */\n  async _doAcquire() {\n    if (!this._hasIdleConnection() || this.#closed) return Promise.reject();\n    let conn;\n    let mustRecheckSize = false;\n    while ((conn = this.#idleConnections.shift()) != null) {\n      //just check connection state first\n      if (conn.isValid()) {\n        this.#activeConnections[conn.threadId] = conn;\n        //if not used for some time, validate connection with a COM_PING\n        if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {\n          try {\n            const cmdParam = new CommandParameter(null, null, {\n              timeout: this.opts.pingTimeout\n            });\n            await new Promise(conn.ping.bind(conn, cmdParam));\n          } catch (e) {\n            delete this.#activeConnections[conn.threadId];\n            continue;\n          }\n        }\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        if (mustRecheckSize) setImmediate(this.emit.bind(this, 'validateSize'));\n        return Promise.resolve(conn);\n      }\n      mustRecheckSize = true;\n    }\n    setImmediate(this.emit.bind(this, 'validateSize'));\n    return Promise.reject();\n  }\n  _requestTimeoutHandler() {\n    //handle next Timer\n    this.#requestTimeoutId = null;\n    const currTime = Date.now();\n    let request;\n    while (request = this.#requests.peekFront()) {\n      if (request.timeout <= currTime) {\n        this.#requests.shift();\n        let err = Errors.createError(`retrieve connection from pool timeout after ${Math.abs(Date.now() - (request.timeout - this.opts.acquireTimeout))}ms${this._errorMsgAddon()}`, Errors.ER_GET_CONNECTION_TIMEOUT, null, 'HY000', null, false, request.stack);\n\n        // in order to provide more information when configuration is wrong / server is down\n        if (this.activeConnections() === 0 && this.#errorCreatingConnection) {\n          const errConnMsg = this.#errorCreatingConnection.message.split('\\n')[0];\n          err.message = err.message + `\\n    connection error: ${errConnMsg}`;\n        }\n        request.reject(err);\n      } else {\n        this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n  _searchInfo() {\n    let info = null;\n    let conn = this.#idleConnections.get(0);\n    if (!conn) {\n      for (const threadId in Object.keys(this.#activeConnections)) {\n        conn = this.#activeConnections[threadId];\n        if (!conn) {\n          break;\n        }\n      }\n    }\n    if (conn) {\n      info = conn.info;\n    }\n    return info;\n  }\n  _rejectTask(task, err) {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    task.reject(err);\n    this._requestTimeoutHandler();\n  }\n  async _createConnection() {\n    const conn = new Connection(this.opts.connOptions);\n    await conn.connect();\n    const pool = this;\n    conn.forceEnd = conn.end;\n    conn.release = function (resolve) {\n      if (pool.#closed || !conn.isValid()) {\n        pool._destroy(conn);\n        resolve();\n        return;\n      }\n      if (pool.opts.noControlAfterUse) {\n        pool.release(conn);\n        resolve();\n        return;\n      }\n      //if server permit it, reset the connection, or rollback only if not\n      // COM_RESET_CONNECTION exist since mysql 5.7.3 and mariadb 10.2.4\n      // but not possible to use it with mysql waiting for https://bugs.mysql.com/bug.php?id=97633 correction.\n      // and mariadb only since https://jira.mariadb.org/browse/MDEV-18281\n      let revertFunction;\n      if (pool.opts.resetAfterUse && conn.info.isMariaDB() && (conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22) || conn.info.hasMinVersion(10, 3, 13))) {\n        revertFunction = conn.reset.bind(conn, new CommandParameter());\n      } else revertFunction = conn.changeTransaction.bind(conn, new CommandParameter('ROLLBACK'));\n      new Promise(revertFunction).then(pool.release.bind(pool, conn), pool._destroy.bind(pool, conn)).finally(resolve);\n    };\n    conn.end = conn.release;\n    return conn;\n  }\n  _leakedConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection && connection.leaked) counter++;\n    }\n    return counter;\n  }\n  _errorMsgAddon() {\n    if (this.opts.leakDetectionTimeout > 0) {\n      return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${this.opts.connectionLimit})`;\n    }\n    return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit})`;\n  }\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  get closed() {\n    return this.#closed;\n  }\n\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n  totalConnections() {\n    return this.activeConnections() + this.idleConnections();\n  }\n\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n  activeConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection) counter++;\n    }\n    return counter;\n  }\n\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n  idleConnections() {\n    return this.#idleConnections.length;\n  }\n\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n  taskQueueSize() {\n    return this.#requests.length;\n  }\n  escape(value) {\n    return Utils.escape(this.opts.connOptions, this._searchInfo(), value);\n  }\n  escapeId(value) {\n    return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  //*****************************************************************\n  // promise methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   * @param cmdParam for stackTrace error\n   * @return {Promise}\n   */\n  getConnection(cmdParam) {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is closed', Errors.ER_POOL_ALREADY_CLOSED, null, 'HY000', null, false, cmdParam.stack));\n    }\n    return this._doAcquire().then(conn => {\n      // connection is available. process task\n      this.emit('acquire', conn);\n      return conn;\n    }, () => {\n      if (this.#closed) {\n        throw Errors.createError('Cannot add request to pool, pool is closed', Errors.ER_POOL_ALREADY_CLOSED, null, 'HY000', null, false, cmdParam.stack);\n      }\n      // no idle connection available\n      // create a new connection if limit is not reached\n      setImmediate(this.emit.bind(this, 'validateSize'));\n      return new Promise(function (resolver, rejecter) {\n        // stack request\n        setImmediate(this.emit.bind(this, 'enqueue'));\n        const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);\n        this.#requests.push(request);\n        if (!this.#requestTimeoutId) {\n          this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout);\n        }\n      }.bind(this));\n    });\n  }\n\n  /**\n   * Close all connection in pool\n   * Ends in multiple step :\n   * - close idle connections\n   * - ensure that no new request is possible\n   *   (active connection release are automatically closed on release)\n   * - if remaining, after 10 seconds, close remaining active connections\n   *\n   * @return Promise\n   */\n  end() {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is already closed', Errors.ER_POOL_ALREADY_CLOSED));\n    }\n    this.#closed = true;\n    clearInterval(this.#unusedConnectionRemoverId);\n    clearInterval(this._sizeHandlerTimeout);\n    const cmdParam = new CommandParameter();\n    if (this.opts.trace) Error.captureStackTrace(cmdParam);\n    //close unused connections\n    const idleConnectionsEndings = [];\n    let conn;\n    while (conn = this.#idleConnections.shift()) {\n      idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));\n    }\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n\n    //reject all waiting task\n    if (!this.#requests.isEmpty()) {\n      const err = Errors.createError('pool is ending, connection request aborted', Errors.ER_CLOSING_POOL, null, 'HY000', null, false, cmdParam.stack);\n      let task;\n      while (task = this.#requests.shift()) {\n        task.reject(err);\n      }\n    }\n    const pool = this;\n    return Promise.all(idleConnectionsEndings).then(async () => {\n      if (pool.activeConnections() > 0) {\n        // wait up to 10 seconds, that active connection are released\n        let remaining = 100;\n        while (remaining-- > 0) {\n          if (pool.activeConnections() > 0) {\n            await new Promise(res => setTimeout(() => res(), 100));\n          }\n        }\n\n        // force close any remaining active connections\n        for (const connection of Object.values(pool.#activeConnections)) {\n          if (connection) connection.destroy();\n        }\n      }\n      return Promise.resolve();\n    });\n  }\n}\nclass Request {\n  constructor(timeout, stack, resolver, rejecter) {\n    this.timeout = timeout;\n    this.stack = stack;\n    this.resolver = resolver;\n    this.rejecter = rejecter;\n  }\n  reject(err) {\n    process.nextTick(this.rejecter, err);\n  }\n}\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","Queue","Errors","Utils","Connection","CommandParameter","Pool","opts","closed","connectionInCreation","errorCreatingConnection","idleConnections","activeConnections","requests","unusedConnectionRemoverId","requestTimeoutId","connErrorNumber","initialized","_sizeHandlerTimeout","constructor","options","on","_requestsHandler","_sizeHandler","_doCreateConnection","resolve","reject","timeoutEnd","_createConnection","then","conn","forceEnd","createFatalError","ER_ADD_CONNECTION_CLOSED_POOL","lastUse","Date","now","nativeDestroy","destroy","bind","pool","_endLeak","threadId","emit","once","idx","currConn","peekAt","removeOne","Math","min","minDelayValidation","setTimeout","isEmpty","push","catch","err","errno","message","_errorMsgAddon","_destroy","totalConnections","_stopReaping","release","isValid","process","nextTick","_checkLeak","leaked","leakProcess","console","log","info","leakDetectionTimeout","clearTimeout","_startReaping","idleTimeout","setInterval","_reaper","clearInterval","idleTimeRemoval","maxRemoval","max","length","minimumIdle","peek","shift","_shouldCreateMoreConnections","connectionLimit","setImmediate","initializationTimeout","Promise","request","resolver","unshift","_requestTimeoutHandler","_hasIdleConnection","_doAcquire","mustRecheckSize","cmdParam","timeout","pingTimeout","ping","e","currTime","peekFront","createError","abs","acquireTimeout","ER_GET_CONNECTION_TIMEOUT","stack","errConnMsg","split","_searchInfo","get","Object","keys","_rejectTask","task","connOptions","connect","end","noControlAfterUse","revertFunction","resetAfterUse","isMariaDB","serverVersion","minor","hasMinVersion","reset","changeTransaction","finally","_leakedConnections","counter","connection","values","taskQueueSize","escape","value","escapeId","getConnection","ER_POOL_ALREADY_CLOSED","rejecter","Request","trace","Error","captureStackTrace","idleConnectionsEndings","ER_CLOSING_POOL","all","remaining","res","module","exports"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/pool.js"],"sourcesContent":["'use strict';\n\nconst { EventEmitter } = require('events');\n\nconst Queue = require('denque');\nconst Errors = require('./misc/errors');\nconst Utils = require('./misc/utils');\nconst Connection = require('./connection');\nconst CommandParameter = require('./command-parameter');\n\nclass Pool extends EventEmitter {\n  opts;\n  #closed = false;\n  #connectionInCreation = false;\n  #errorCreatingConnection = null;\n  #idleConnections = new Queue();\n  #activeConnections = {};\n  #requests = new Queue();\n  #unusedConnectionRemoverId;\n  #requestTimeoutId;\n  #connErrorNumber = 0;\n  #initialized = false;\n  _sizeHandlerTimeout;\n\n  constructor(options) {\n    super();\n    this.opts = options;\n\n    this.on('_idle', this._requestsHandler);\n    this.on('validateSize', this._sizeHandler);\n\n    this._sizeHandler();\n  }\n\n  //*****************************************************************\n  // pool automatic handlers\n  //*****************************************************************\n\n  _doCreateConnection(resolve, reject, timeoutEnd) {\n    this._createConnection()\n      .then((conn) => {\n        if (this.#closed) {\n          conn.forceEnd(\n            null,\n            () => {},\n            () => {}\n          );\n          reject(\n            new Errors.createFatalError(\n              'Cannot create new connection to pool, pool closed',\n              Errors.ER_ADD_CONNECTION_CLOSED_POOL\n            )\n          );\n          return;\n        }\n\n        conn.lastUse = Date.now();\n        const nativeDestroy = conn.destroy.bind(conn);\n        const pool = this;\n\n        conn.destroy = function () {\n          pool._endLeak(conn);\n          delete pool.#activeConnections[conn.threadId];\n          nativeDestroy();\n          pool.emit('validateSize');\n        };\n\n        conn.once('error', function () {\n          let idx = 0;\n          let currConn;\n          pool._endLeak(conn);\n          delete pool.#activeConnections[conn.threadId];\n          while ((currConn = pool.#idleConnections.peekAt(idx))) {\n            if (currConn === conn) {\n              pool.#idleConnections.removeOne(idx);\n              continue;\n            }\n            //since connection did have an error, other waiting connection might too\n            //forcing validation when borrowed next time, even if \"minDelayValidation\" is not reached.\n            currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool.opts.minDelayValidation);\n            idx++;\n          }\n          setTimeout(() => {\n            if (!pool.#requests.isEmpty()) {\n              pool._sizeHandler();\n            }\n          }, 0);\n        });\n\n        this.#idleConnections.push(conn);\n        this.#connectionInCreation = false;\n        this.emit('_idle');\n        this.emit('connection', conn);\n        resolve(conn);\n      })\n      .catch((err) => {\n        //if timeout is reached or authentication fail return error\n        if (\n          this.#closed ||\n          (err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698)) ||\n          timeoutEnd < Date.now()\n        ) {\n          err.message = err.message + this._errorMsgAddon();\n          reject(err);\n          return;\n        }\n        setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);\n      });\n  }\n\n  _destroy(conn) {\n    this._endLeak(conn);\n    delete this.#activeConnections[conn.threadId];\n    conn.lastUse = Date.now();\n    conn.forceEnd(\n      null,\n      () => {},\n      () => {}\n    );\n\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n\n    this.emit('validateSize');\n  }\n\n  release(conn) {\n    // ensure releasing only once\n    if (this.#activeConnections[conn.threadId]) {\n      this._endLeak(conn);\n      this.#activeConnections[conn.threadId] = null;\n      conn.lastUse = Date.now();\n\n      if (this.#closed) {\n        conn.forceEnd(\n          null,\n          () => {},\n          () => {}\n        );\n      } else if (conn.isValid()) {\n        this.emit('release', conn);\n        this.#idleConnections.push(conn);\n        process.nextTick(this.emit.bind(this, '_idle'));\n      } else {\n        this.emit('validateSize');\n      }\n    }\n  }\n\n  _checkLeak(conn) {\n    conn.lastUse = Date.now();\n    conn.leaked = false;\n    conn.leakProcess = setTimeout(\n      (conn) => {\n        conn.leaked = true;\n        console.log(\n          `A possible connection leak on the thread ${\n            conn.info.threadId\n          } (the connection not returned to the pool since ${\n            Date.now() - conn.lastUse\n          } ms). Has the connection.release() been called ?` + this._errorMsgAddon()\n        );\n      },\n      this.opts.leakDetectionTimeout,\n      conn\n    );\n  }\n\n  _endLeak(conn) {\n    if (conn.leakProcess) {\n      clearTimeout(conn.leakProcess);\n      conn.leakProcess = null;\n      if (conn.leaked) {\n        console.log(`Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`);\n      }\n    }\n  }\n\n  /**\n   * Permit to remove idle connection if unused for some time.\n   */\n  _startReaping() {\n    if (!this.#unusedConnectionRemoverId && this.opts.idleTimeout > 0) {\n      this.#unusedConnectionRemoverId = setInterval(this._reaper.bind(this), 500);\n    }\n  }\n\n  _stopReaping() {\n    if (this.#unusedConnectionRemoverId && this.totalConnections() === 0) {\n      clearInterval(this.#unusedConnectionRemoverId);\n    }\n  }\n\n  _reaper() {\n    const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1000;\n    let maxRemoval = Math.max(0, this.#idleConnections.length - this.opts.minimumIdle);\n    while (maxRemoval > 0) {\n      const conn = this.#idleConnections.peek();\n      maxRemoval--;\n      if (conn && conn.lastUse < idleTimeRemoval) {\n        this.#idleConnections.shift();\n        conn.forceEnd(\n          null,\n          () => {},\n          () => {}\n        );\n        continue;\n      }\n      break;\n    }\n\n    if (this.totalConnections() === 0) {\n      this._stopReaping();\n    }\n    this.emit('validateSize');\n  }\n\n  _shouldCreateMoreConnections() {\n    return (\n      !this.#connectionInCreation &&\n      this.#idleConnections.length < this.opts.minimumIdle &&\n      this.totalConnections() < this.opts.connectionLimit &&\n      !this.#closed\n    );\n  }\n\n  /**\n   * Grow pool connections until reaching connection limit.\n   */\n  _sizeHandler() {\n    if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {\n      this.#connectionInCreation = true;\n      setImmediate(\n        function () {\n          const timeoutEnd = Date.now() + this.opts.initializationTimeout;\n          new Promise((resolve, reject) => {\n            this._doCreateConnection(resolve, reject, timeoutEnd);\n          })\n            .then(() => {\n              this.#initialized = true;\n              this.#errorCreatingConnection = null;\n              this.#connErrorNumber = 0;\n              if (this._shouldCreateMoreConnections()) {\n                this.emit('validateSize');\n              }\n              this._startReaping();\n            })\n            .catch((err) => {\n              this.#connectionInCreation = false;\n              if (!this.#closed) {\n                if (!this.#initialized) {\n                  err.message = 'Error during pool initialization: ' + err.message;\n                } else {\n                  err.message = 'Pool fails to create connection: ' + err.message;\n                }\n                this.#errorCreatingConnection = err;\n                this.emit('error', err);\n\n                //delay next try\n                this._sizeHandlerTimeout = setTimeout(\n                  function () {\n                    this._sizeHandlerTimeout = null;\n                    if (!this.#requests.isEmpty()) {\n                      this._sizeHandler();\n                    }\n                  }.bind(this),\n                  Math.min(++this.#connErrorNumber * 500, 10000)\n                );\n              }\n            });\n        }.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Launch next waiting task request if available connections.\n   */\n  _requestsHandler() {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    const request = this.#requests.shift();\n    if (request) {\n      const conn = this.#idleConnections.shift();\n      if (conn) {\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        this.emit('acquire', conn);\n        this.#activeConnections[conn.threadId] = conn;\n        request.resolver(conn);\n      } else {\n        this.#requests.unshift(request);\n      }\n      this._requestTimeoutHandler();\n    }\n  }\n\n  _hasIdleConnection() {\n    return !this.#idleConnections.isEmpty();\n  }\n\n  /**\n   * Return an idle Connection.\n   * If connection has not been used for some time ( minDelayValidation), validate connection status.\n   *\n   * @returns {Promise<Connection>} connection of null of no valid idle connection.\n   */\n  async _doAcquire() {\n    if (!this._hasIdleConnection() || this.#closed) return Promise.reject();\n    let conn;\n    let mustRecheckSize = false;\n    while ((conn = this.#idleConnections.shift()) != null) {\n      //just check connection state first\n      if (conn.isValid()) {\n        this.#activeConnections[conn.threadId] = conn;\n        //if not used for some time, validate connection with a COM_PING\n        if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {\n          try {\n            const cmdParam = new CommandParameter(null, null, { timeout: this.opts.pingTimeout });\n            await new Promise(conn.ping.bind(conn, cmdParam));\n          } catch (e) {\n            delete this.#activeConnections[conn.threadId];\n            continue;\n          }\n        }\n        if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);\n        if (mustRecheckSize) setImmediate(this.emit.bind(this, 'validateSize'));\n        return Promise.resolve(conn);\n      }\n      mustRecheckSize = true;\n    }\n    setImmediate(this.emit.bind(this, 'validateSize'));\n    return Promise.reject();\n  }\n\n  _requestTimeoutHandler() {\n    //handle next Timer\n    this.#requestTimeoutId = null;\n    const currTime = Date.now();\n    let request;\n    while ((request = this.#requests.peekFront())) {\n      if (request.timeout <= currTime) {\n        this.#requests.shift();\n\n        let err = Errors.createError(\n          `retrieve connection from pool timeout after ${Math.abs(\n            Date.now() - (request.timeout - this.opts.acquireTimeout)\n          )}ms${this._errorMsgAddon()}`,\n          Errors.ER_GET_CONNECTION_TIMEOUT,\n          null,\n          'HY000',\n          null,\n          false,\n          request.stack\n        );\n\n        // in order to provide more information when configuration is wrong / server is down\n        if (this.activeConnections() === 0 && this.#errorCreatingConnection) {\n          const errConnMsg = this.#errorCreatingConnection.message.split('\\n')[0];\n          err.message = err.message + `\\n    connection error: ${errConnMsg}`;\n        }\n        request.reject(err);\n      } else {\n        this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Search info object of an existing connection. to know server type and version.\n   * @returns information object if connection available.\n   */\n  _searchInfo() {\n    let info = null;\n    let conn = this.#idleConnections.get(0);\n\n    if (!conn) {\n      for (const threadId in Object.keys(this.#activeConnections)) {\n        conn = this.#activeConnections[threadId];\n        if (!conn) {\n          break;\n        }\n      }\n    }\n\n    if (conn) {\n      info = conn.info;\n    }\n    return info;\n  }\n\n  _rejectTask(task, err) {\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n    task.reject(err);\n    this._requestTimeoutHandler();\n  }\n\n  async _createConnection() {\n    const conn = new Connection(this.opts.connOptions);\n    await conn.connect();\n    const pool = this;\n    conn.forceEnd = conn.end;\n    conn.release = function (resolve) {\n      if (pool.#closed || !conn.isValid()) {\n        pool._destroy(conn);\n        resolve();\n        return;\n      }\n      if (pool.opts.noControlAfterUse) {\n        pool.release(conn);\n        resolve();\n        return;\n      }\n      //if server permit it, reset the connection, or rollback only if not\n      // COM_RESET_CONNECTION exist since mysql 5.7.3 and mariadb 10.2.4\n      // but not possible to use it with mysql waiting for https://bugs.mysql.com/bug.php?id=97633 correction.\n      // and mariadb only since https://jira.mariadb.org/browse/MDEV-18281\n      let revertFunction;\n      if (\n        pool.opts.resetAfterUse &&\n        conn.info.isMariaDB() &&\n        ((conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22)) ||\n          conn.info.hasMinVersion(10, 3, 13))\n      ) {\n        revertFunction = conn.reset.bind(conn, new CommandParameter());\n      } else revertFunction = conn.changeTransaction.bind(conn, new CommandParameter('ROLLBACK'));\n\n      new Promise(revertFunction).then(pool.release.bind(pool, conn), pool._destroy.bind(pool, conn)).finally(resolve);\n    };\n    conn.end = conn.release;\n    return conn;\n  }\n\n  _leakedConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection && connection.leaked) counter++;\n    }\n    return counter;\n  }\n\n  _errorMsgAddon() {\n    if (this.opts.leakDetectionTimeout > 0) {\n      return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${\n        this.opts.connectionLimit\n      })`;\n    }\n    return `\\n    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${\n      this.opts.connectionLimit\n    })`;\n  }\n\n  //*****************************************************************\n  // public methods\n  //*****************************************************************\n\n  get closed() {\n    return this.#closed;\n  }\n\n  /**\n   * Get current total connection number.\n   * @return {number}\n   */\n  totalConnections() {\n    return this.activeConnections() + this.idleConnections();\n  }\n\n  /**\n   * Get current active connections.\n   * @return {number}\n   */\n  activeConnections() {\n    let counter = 0;\n    for (const connection of Object.values(this.#activeConnections)) {\n      if (connection) counter++;\n    }\n    return counter;\n  }\n\n  /**\n   * Get current idle connection number.\n   * @return {number}\n   */\n  idleConnections() {\n    return this.#idleConnections.length;\n  }\n\n  /**\n   * Get current stacked connection request.\n   * @return {number}\n   */\n  taskQueueSize() {\n    return this.#requests.length;\n  }\n\n  escape(value) {\n    return Utils.escape(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  escapeId(value) {\n    return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);\n  }\n\n  //*****************************************************************\n  // promise methods\n  //*****************************************************************\n\n  /**\n   * Retrieve a connection from pool.\n   * Create a new one, if limit is not reached.\n   * wait until acquireTimeout.\n   * @param cmdParam for stackTrace error\n   * @return {Promise}\n   */\n  getConnection(cmdParam) {\n    if (this.#closed) {\n      return Promise.reject(\n        Errors.createError('pool is closed', Errors.ER_POOL_ALREADY_CLOSED, null, 'HY000', null, false, cmdParam.stack)\n      );\n    }\n    return this._doAcquire().then(\n      (conn) => {\n        // connection is available. process task\n        this.emit('acquire', conn);\n        return conn;\n      },\n      () => {\n        if (this.#closed) {\n          throw Errors.createError(\n            'Cannot add request to pool, pool is closed',\n            Errors.ER_POOL_ALREADY_CLOSED,\n            null,\n            'HY000',\n            null,\n            false,\n            cmdParam.stack\n          );\n        }\n        // no idle connection available\n        // create a new connection if limit is not reached\n        setImmediate(this.emit.bind(this, 'validateSize'));\n        return new Promise(\n          function (resolver, rejecter) {\n            // stack request\n            setImmediate(this.emit.bind(this, 'enqueue'));\n            const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);\n            this.#requests.push(request);\n            if (!this.#requestTimeoutId) {\n              this.#requestTimeoutId = setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout);\n            }\n          }.bind(this)\n        );\n      }\n    );\n  }\n\n  /**\n   * Close all connection in pool\n   * Ends in multiple step :\n   * - close idle connections\n   * - ensure that no new request is possible\n   *   (active connection release are automatically closed on release)\n   * - if remaining, after 10 seconds, close remaining active connections\n   *\n   * @return Promise\n   */\n  end() {\n    if (this.#closed) {\n      return Promise.reject(Errors.createError('pool is already closed', Errors.ER_POOL_ALREADY_CLOSED));\n    }\n    this.#closed = true;\n    clearInterval(this.#unusedConnectionRemoverId);\n    clearInterval(this._sizeHandlerTimeout);\n    const cmdParam = new CommandParameter();\n    if (this.opts.trace) Error.captureStackTrace(cmdParam);\n    //close unused connections\n    const idleConnectionsEndings = [];\n    let conn;\n    while ((conn = this.#idleConnections.shift())) {\n      idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));\n    }\n\n    clearTimeout(this.#requestTimeoutId);\n    this.#requestTimeoutId = null;\n\n    //reject all waiting task\n    if (!this.#requests.isEmpty()) {\n      const err = Errors.createError(\n        'pool is ending, connection request aborted',\n        Errors.ER_CLOSING_POOL,\n        null,\n        'HY000',\n        null,\n        false,\n        cmdParam.stack\n      );\n      let task;\n      while ((task = this.#requests.shift())) {\n        task.reject(err);\n      }\n    }\n    const pool = this;\n    return Promise.all(idleConnectionsEndings).then(async () => {\n      if (pool.activeConnections() > 0) {\n        // wait up to 10 seconds, that active connection are released\n        let remaining = 100;\n        while (remaining-- > 0) {\n          if (pool.activeConnections() > 0) {\n            await new Promise((res) => setTimeout(() => res(), 100));\n          }\n        }\n\n        // force close any remaining active connections\n        for (const connection of Object.values(pool.#activeConnections)) {\n          if (connection) connection.destroy();\n        }\n      }\n      return Promise.resolve();\n    });\n  }\n}\n\nclass Request {\n  constructor(timeout, stack, resolver, rejecter) {\n    this.timeout = timeout;\n    this.stack = stack;\n    this.resolver = resolver;\n    this.rejecter = rejecter;\n  }\n\n  reject(err) {\n    process.nextTick(this.rejecter, err);\n  }\n}\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}