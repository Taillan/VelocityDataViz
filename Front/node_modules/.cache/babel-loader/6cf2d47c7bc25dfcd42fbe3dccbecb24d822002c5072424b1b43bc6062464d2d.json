{"ast":null,"code":"const Errors = require('../misc/errors');\nconst State = {\n  Normal: 1 /* inside  query */,\n  String: 2 /* inside string */,\n  SlashStarComment: 3 /* inside slash-star comment */,\n  Escape: 4 /* found backslash */,\n  EOLComment: 5 /* # comment, or // comment, or -- comment */,\n  Backtick: 6 /* found backtick */,\n  Placeholder: 7 /* found placeholder */\n};\n\nconst SLASH_BYTE = '/'.charCodeAt(0);\nconst STAR_BYTE = '*'.charCodeAt(0);\nconst BACKSLASH_BYTE = '\\\\'.charCodeAt(0);\nconst HASH_BYTE = '#'.charCodeAt(0);\nconst MINUS_BYTE = '-'.charCodeAt(0);\nconst LINE_FEED_BYTE = '\\n'.charCodeAt(0);\nconst DBL_QUOTE_BYTE = '\"'.charCodeAt(0);\nconst QUOTE_BYTE = \"'\".charCodeAt(0);\nconst RADICAL_BYTE = '`'.charCodeAt(0);\nconst QUESTION_MARK_BYTE = '?'.charCodeAt(0);\nconst COLON_BYTE = ':'.charCodeAt(0);\n\n/**\n * Set question mark position (question mark).\n * Question mark in comment are not taken in account\n *\n * @returns {Array} question mark position\n */\nmodule.exports.splitQuery = function (query) {\n  let paramPositions = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    if (state === State.Escape && !(query[i] === QUOTE_BYTE && singleQuotes || query[i] === DBL_QUOTE_BYTE && !singleQuotes)) {\n      state = State.String;\n      lastChar = query[i];\n      continue;\n    }\n    switch (query[i]) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i, ++i);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = query[i];\n  }\n  return paramPositions;\n};\n\n/**\n * Split query according to parameters using placeholder.\n *\n * @param query           query bytes\n * @param info            connection information\n * @param initialValues   placeholder object\n * @param displaySql      display sql function\n * @returns {{paramPositions: Array, values: Array}}\n */\nmodule.exports.splitQueryPlaceholder = function (query, info, initialValues, displaySql) {\n  let paramPositions = [];\n  let values = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  let car;\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    car = query[i];\n    if (state === State.Escape && !(car === QUOTE_BYTE && singleQuotes || car === DBL_QUOTE_BYTE && !singleQuotes)) {\n      state = State.String;\n      lastChar = car;\n      continue;\n    }\n    switch (car) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i);\n          paramPositions.push(++i);\n        }\n        break;\n      case COLON_BYTE:\n        if (state === State.Normal) {\n          let j = 1;\n          while (i + j < len && query[i + j] >= '0'.charCodeAt(0) && query[i + j] <= '9'.charCodeAt(0) || query[i + j] >= 'A'.charCodeAt(0) && query[i + j] <= 'Z'.charCodeAt(0) || query[i + j] >= 'a'.charCodeAt(0) && query[i + j] <= 'z'.charCodeAt(0) || query[i + j] === '-'.charCodeAt(0) || query[i + j] === '_'.charCodeAt(0)) {\n            j++;\n          }\n          paramPositions.push(i, i + j);\n          const placeholderName = query.toString('utf8', i + 1, i + j);\n          i += j;\n          const val = initialValues[placeholderName];\n          if (val === undefined) {\n            throw Errors.createError(`Placeholder '${placeholderName}' is not defined`, Errors.ER_PLACEHOLDER_UNDEFINED, info, 'HY000', displaySql.call());\n          }\n          values.push(val);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = car;\n  }\n  return {\n    paramPositions: paramPositions,\n    values: values\n  };\n};\nmodule.exports.searchPlaceholder = function (sql) {\n  let sqlPlaceHolder = '';\n  let placeHolderIndex = [];\n  let state = State.Normal;\n  let lastChar = '\\0';\n  let singleQuotes = false;\n  let lastParameterPosition = 0;\n  let idx = 0;\n  let car = sql.charAt(idx++);\n  let placeholderName;\n  while (car !== '') {\n    if (state === State.Escape && !(car === \"'\" && singleQuotes || car === '\"' && !singleQuotes)) {\n      state = State.String;\n      lastChar = car;\n      car = sql.charAt(idx++);\n      continue;\n    }\n    switch (car) {\n      case '*':\n        if (state === State.Normal && lastChar === '/') state = State.SlashStarComment;\n        break;\n      case '/':\n        if (state === State.SlashStarComment && lastChar === '*') state = State.Normal;\n        break;\n      case '#':\n        if (state === State.Normal) state = State.EOLComment;\n        break;\n      case '-':\n        if (state === State.Normal && lastChar === '-') {\n          state = State.EOLComment;\n        }\n        break;\n      case '\\n':\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n      case '\"':\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape && !singleQuotes) {\n          state = State.String;\n        }\n        break;\n      case \"'\":\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n          singleQuotes = false;\n        } else if (state === State.Escape && singleQuotes) {\n          state = State.String;\n        }\n        break;\n      case '\\\\':\n        if (state === State.String) state = State.Escape;\n        break;\n      case ':':\n        if (state === State.Normal) {\n          sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + '?';\n          placeholderName = '';\n          while ((car = sql.charAt(idx++)) !== '' && car >= '0' && car <= '9' || car >= 'A' && car <= 'Z' || car >= 'a' && car <= 'z' || car === '-' || car === '_') {\n            placeholderName += car;\n          }\n          idx--;\n          placeHolderIndex.push(placeholderName);\n          lastParameterPosition = idx;\n        }\n        break;\n      case '`':\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n    }\n    lastChar = car;\n    car = sql.charAt(idx++);\n  }\n  if (lastParameterPosition === 0) {\n    sqlPlaceHolder = sql;\n  } else {\n    sqlPlaceHolder += sql.substring(lastParameterPosition);\n  }\n  return {\n    sql: sqlPlaceHolder,\n    placeHolderIndex: placeHolderIndex\n  };\n};\n\n/**\n * Ensure that filename requested by server corresponds to query\n * protocol : https://mariadb.com/kb/en/library/local_infile-packet/\n *\n * @param sql         query\n * @param parameters  parameters if any\n * @param fileName    server requested file\n * @returns {boolean} is filename corresponding to query\n */\nmodule.exports.validateFileName = function (sql, parameters, fileName) {\n  // in case of windows, file name in query are escaped\n  // so for example LOAD DATA LOCAL INFILE 'C:\\\\Temp\\\\myFile.txt' ...\n  // but server return 'C:\\Temp\\myFile.txt'\n  // so with regex escaped, must test LOAD DATA LOCAL INFILE 'C:\\\\\\\\Temp\\\\\\\\myFile.txt'\n  let queryValidator = new RegExp(\"^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+'\" + fileName.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace('.', '\\\\.') + \"'\", 'i');\n  if (queryValidator.test(sql)) return true;\n  if (parameters != null) {\n    queryValidator = new RegExp('^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+\\\\?', 'i');\n    if (queryValidator.test(sql) && parameters.length > 0) {\n      if (Array.isArray(parameters)) {\n        return parameters[0].toLowerCase() === fileName.toLowerCase();\n      }\n      return parameters.toLowerCase() === fileName.toLowerCase();\n    }\n  }\n  return false;\n};","map":{"version":3,"names":["Errors","require","State","Normal","String","SlashStarComment","Escape","EOLComment","Backtick","Placeholder","SLASH_BYTE","charCodeAt","STAR_BYTE","BACKSLASH_BYTE","HASH_BYTE","MINUS_BYTE","LINE_FEED_BYTE","DBL_QUOTE_BYTE","QUOTE_BYTE","RADICAL_BYTE","QUESTION_MARK_BYTE","COLON_BYTE","module","exports","splitQuery","query","paramPositions","state","lastChar","singleQuotes","len","length","i","push","splitQueryPlaceholder","info","initialValues","displaySql","values","car","j","placeholderName","toString","val","undefined","createError","ER_PLACEHOLDER_UNDEFINED","call","searchPlaceholder","sql","sqlPlaceHolder","placeHolderIndex","lastParameterPosition","idx","charAt","substring","validateFileName","parameters","fileName","queryValidator","RegExp","replace","test","Array","isArray","toLowerCase"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/misc/parse.js"],"sourcesContent":["const Errors = require('../misc/errors');\n\nconst State = {\n  Normal: 1 /* inside  query */,\n  String: 2 /* inside string */,\n  SlashStarComment: 3 /* inside slash-star comment */,\n  Escape: 4 /* found backslash */,\n  EOLComment: 5 /* # comment, or // comment, or -- comment */,\n  Backtick: 6 /* found backtick */,\n  Placeholder: 7 /* found placeholder */\n};\n\nconst SLASH_BYTE = '/'.charCodeAt(0);\nconst STAR_BYTE = '*'.charCodeAt(0);\nconst BACKSLASH_BYTE = '\\\\'.charCodeAt(0);\nconst HASH_BYTE = '#'.charCodeAt(0);\nconst MINUS_BYTE = '-'.charCodeAt(0);\nconst LINE_FEED_BYTE = '\\n'.charCodeAt(0);\nconst DBL_QUOTE_BYTE = '\"'.charCodeAt(0);\nconst QUOTE_BYTE = \"'\".charCodeAt(0);\nconst RADICAL_BYTE = '`'.charCodeAt(0);\nconst QUESTION_MARK_BYTE = '?'.charCodeAt(0);\nconst COLON_BYTE = ':'.charCodeAt(0);\n\n/**\n * Set question mark position (question mark).\n * Question mark in comment are not taken in account\n *\n * @returns {Array} question mark position\n */\nmodule.exports.splitQuery = function (query) {\n  let paramPositions = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    if (\n      state === State.Escape &&\n      !((query[i] === QUOTE_BYTE && singleQuotes) || (query[i] === DBL_QUOTE_BYTE && !singleQuotes))\n    ) {\n      state = State.String;\n      lastChar = query[i];\n      continue;\n    }\n    switch (query[i]) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i, ++i);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = query[i];\n  }\n  return paramPositions;\n};\n\n/**\n * Split query according to parameters using placeholder.\n *\n * @param query           query bytes\n * @param info            connection information\n * @param initialValues   placeholder object\n * @param displaySql      display sql function\n * @returns {{paramPositions: Array, values: Array}}\n */\nmodule.exports.splitQueryPlaceholder = function (query, info, initialValues, displaySql) {\n  let paramPositions = [];\n  let values = [];\n  let state = State.Normal;\n  let lastChar = 0x00;\n  let singleQuotes = false;\n  let car;\n\n  const len = query.length;\n  for (let i = 0; i < len; i++) {\n    car = query[i];\n    if (\n      state === State.Escape &&\n      !((car === QUOTE_BYTE && singleQuotes) || (car === DBL_QUOTE_BYTE && !singleQuotes))\n    ) {\n      state = State.String;\n      lastChar = car;\n      continue;\n    }\n    switch (car) {\n      case STAR_BYTE:\n        if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.SlashStarComment;\n        }\n        break;\n\n      case SLASH_BYTE:\n        if (state === State.SlashStarComment && lastChar === STAR_BYTE) {\n          state = State.Normal;\n        } else if (state === State.Normal && lastChar === SLASH_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case HASH_BYTE:\n        if (state === State.Normal) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case MINUS_BYTE:\n        if (state === State.Normal && lastChar === MINUS_BYTE) {\n          state = State.EOLComment;\n        }\n        break;\n\n      case LINE_FEED_BYTE:\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case DBL_QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case QUOTE_BYTE:\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape) {\n          state = State.String;\n        }\n        break;\n\n      case BACKSLASH_BYTE:\n        if (state === State.String) {\n          state = State.Escape;\n        }\n        break;\n      case QUESTION_MARK_BYTE:\n        if (state === State.Normal) {\n          paramPositions.push(i);\n          paramPositions.push(++i);\n        }\n        break;\n      case COLON_BYTE:\n        if (state === State.Normal) {\n          let j = 1;\n\n          while (\n            (i + j < len && query[i + j] >= '0'.charCodeAt(0) && query[i + j] <= '9'.charCodeAt(0)) ||\n            (query[i + j] >= 'A'.charCodeAt(0) && query[i + j] <= 'Z'.charCodeAt(0)) ||\n            (query[i + j] >= 'a'.charCodeAt(0) && query[i + j] <= 'z'.charCodeAt(0)) ||\n            query[i + j] === '-'.charCodeAt(0) ||\n            query[i + j] === '_'.charCodeAt(0)\n          ) {\n            j++;\n          }\n\n          paramPositions.push(i, i + j);\n\n          const placeholderName = query.toString('utf8', i + 1, i + j);\n          i += j;\n\n          const val = initialValues[placeholderName];\n          if (val === undefined) {\n            throw Errors.createError(\n              `Placeholder '${placeholderName}' is not defined`,\n              Errors.ER_PLACEHOLDER_UNDEFINED,\n              info,\n              'HY000',\n              displaySql.call()\n            );\n          }\n          values.push(val);\n        }\n        break;\n      case RADICAL_BYTE:\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n        break;\n    }\n    lastChar = car;\n  }\n  return { paramPositions: paramPositions, values: values };\n};\n\nmodule.exports.searchPlaceholder = function (sql) {\n  let sqlPlaceHolder = '';\n  let placeHolderIndex = [];\n  let state = State.Normal;\n  let lastChar = '\\0';\n\n  let singleQuotes = false;\n  let lastParameterPosition = 0;\n\n  let idx = 0;\n  let car = sql.charAt(idx++);\n  let placeholderName;\n\n  while (car !== '') {\n    if (state === State.Escape && !((car === \"'\" && singleQuotes) || (car === '\"' && !singleQuotes))) {\n      state = State.String;\n      lastChar = car;\n      car = sql.charAt(idx++);\n      continue;\n    }\n\n    switch (car) {\n      case '*':\n        if (state === State.Normal && lastChar === '/') state = State.SlashStarComment;\n        break;\n\n      case '/':\n        if (state === State.SlashStarComment && lastChar === '*') state = State.Normal;\n        break;\n\n      case '#':\n        if (state === State.Normal) state = State.EOLComment;\n        break;\n\n      case '-':\n        if (state === State.Normal && lastChar === '-') {\n          state = State.EOLComment;\n        }\n        break;\n\n      case '\\n':\n        if (state === State.EOLComment) {\n          state = State.Normal;\n        }\n        break;\n\n      case '\"':\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = false;\n        } else if (state === State.String && !singleQuotes) {\n          state = State.Normal;\n        } else if (state === State.Escape && !singleQuotes) {\n          state = State.String;\n        }\n        break;\n\n      case \"'\":\n        if (state === State.Normal) {\n          state = State.String;\n          singleQuotes = true;\n        } else if (state === State.String && singleQuotes) {\n          state = State.Normal;\n          singleQuotes = false;\n        } else if (state === State.Escape && singleQuotes) {\n          state = State.String;\n        }\n        break;\n\n      case '\\\\':\n        if (state === State.String) state = State.Escape;\n        break;\n\n      case ':':\n        if (state === State.Normal) {\n          sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + '?';\n          placeholderName = '';\n          while (\n            ((car = sql.charAt(idx++)) !== '' && car >= '0' && car <= '9') ||\n            (car >= 'A' && car <= 'Z') ||\n            (car >= 'a' && car <= 'z') ||\n            car === '-' ||\n            car === '_'\n          ) {\n            placeholderName += car;\n          }\n          idx--;\n          placeHolderIndex.push(placeholderName);\n          lastParameterPosition = idx;\n        }\n        break;\n      case '`':\n        if (state === State.Backtick) {\n          state = State.Normal;\n        } else if (state === State.Normal) {\n          state = State.Backtick;\n        }\n    }\n    lastChar = car;\n\n    car = sql.charAt(idx++);\n  }\n  if (lastParameterPosition === 0) {\n    sqlPlaceHolder = sql;\n  } else {\n    sqlPlaceHolder += sql.substring(lastParameterPosition);\n  }\n\n  return { sql: sqlPlaceHolder, placeHolderIndex: placeHolderIndex };\n};\n\n/**\n * Ensure that filename requested by server corresponds to query\n * protocol : https://mariadb.com/kb/en/library/local_infile-packet/\n *\n * @param sql         query\n * @param parameters  parameters if any\n * @param fileName    server requested file\n * @returns {boolean} is filename corresponding to query\n */\nmodule.exports.validateFileName = function (sql, parameters, fileName) {\n  // in case of windows, file name in query are escaped\n  // so for example LOAD DATA LOCAL INFILE 'C:\\\\Temp\\\\myFile.txt' ...\n  // but server return 'C:\\Temp\\myFile.txt'\n  // so with regex escaped, must test LOAD DATA LOCAL INFILE 'C:\\\\\\\\Temp\\\\\\\\myFile.txt'\n  let queryValidator = new RegExp(\n    \"^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+'\" +\n      fileName.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace('.', '\\\\.') +\n      \"'\",\n    'i'\n  );\n  if (queryValidator.test(sql)) return true;\n\n  if (parameters != null) {\n    queryValidator = new RegExp(\n      '^(\\\\s*\\\\/\\\\*([^\\\\*]|\\\\*[^\\\\/])*\\\\*\\\\/)*\\\\s*LOAD\\\\s+DATA\\\\s+((LOW_PRIORITY|CONCURRENT)\\\\s+)?LOCAL\\\\s+INFILE\\\\s+\\\\?',\n      'i'\n    );\n    if (queryValidator.test(sql) && parameters.length > 0) {\n      if (Array.isArray(parameters)) {\n        return parameters[0].toLowerCase() === fileName.toLowerCase();\n      }\n      return parameters.toLowerCase() === fileName.toLowerCase();\n    }\n  }\n  return false;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}