{"ast":null,"code":"'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\nclass BinaryDecoder {\n  static newRow(packet, columns) {\n    packet.skip(1); // skip 0x00 header.\n    return packet.readBuffer(Math.floor((columns.length + 9) / 8));\n  }\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();\n    column.buffer = () => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\n    column.float = () => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\n    column.tiny = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();\n    column.short = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();\n    column.int = () => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\n    column.long = () => isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64();\n    column.decimal = () => isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded();\n    column.date = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\n    column.datetime = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = {\n              type: 'Point'\n            };\n            break;\n          case 'linestring':\n            defaultVal = {\n              type: 'LineString'\n            };\n            break;\n          case 'polygon':\n            defaultVal = {\n              type: 'Polygon'\n            };\n            break;\n          case 'multipoint':\n            defaultVal = {\n              type: 'MultiPoint'\n            };\n            break;\n          case 'multilinestring':\n            defaultVal = {\n              type: 'MultiLineString'\n            };\n            break;\n          case 'multipolygon':\n            defaultVal = {\n              type: 'MultiPolygon'\n            };\n            break;\n          default:\n            defaultVal = {\n              type: column.dataTypeName\n            };\n            break;\n        }\n      }\n      if (isNullBitmap(index, nullBitmap)) {\n        return defaultVal;\n      }\n      return packet.readGeometry(defaultVal);\n    };\n  }\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n    switch (col.columnType) {\n      case FieldType.TINY:\n        return col.signed() ? readTinyBinarySigned : readTinyBinaryUnsigned;\n      case FieldType.YEAR:\n      case FieldType.SHORT:\n        return col.signed() ? readShortBinarySigned : readShortBinaryUnsigned;\n      case FieldType.INT24:\n        return col.signed() ? readMediumBinarySigned : readMediumBinaryUnsigned;\n      case FieldType.INT:\n        return col.signed() ? readIntBinarySigned : readIntBinaryUnsigned;\n      case FieldType.FLOAT:\n        return readFloatBinary;\n      case FieldType.DOUBLE:\n        return readDoubleBinary;\n      case FieldType.BIGINT:\n        if (col.signed()) {\n          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;\n        }\n        return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;\n      case FieldType.DATE:\n        return readDateBinary;\n      case FieldType.DATETIME:\n      case FieldType.TIMESTAMP:\n        return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;\n      case FieldType.TIME:\n        return readTimeBinary;\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometryBinary.bind(null, defaultVal);\n      case FieldType.JSON:\n        //for mysql only => parse string as JSON object\n        return readJsonBinary;\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitBinaryBoolean;\n        }\n        return readBinaryBuffer;\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJsonBinary;\n        }\n        if (col.collation.index === 63) {\n          return readBinaryBuffer;\n        }\n        if (col.isSet()) {\n          return readBinarySet;\n        }\n        return readStringBinary;\n    }\n  }\n}\nconst isNullBitmap = (index, nullBitmap) => {\n  return (nullBitmap[Math.floor((index + 2) / 8)] & 1 << (index + 2) % 8) > 0;\n};\nmodule.exports = BinaryDecoder;\nconst readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt8();\nconst readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();\nconst readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt16();\nconst readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();\nconst readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\nconst readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();\nconst readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\nconst readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readDouble();\nconst readBigintBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigUInt64();\n};\nconst readBigintBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigInt64();\n};\nconst readBigintAsIntBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigUInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(`value ${val} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\nconst readBigintAsIntBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(`value ${val} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\nconst readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return defaultVal;\n  }\n  return packet.readGeometry(defaultVal);\n};\nconst readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\nconst readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\nconst readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);\nconst readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();\nconst readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  //checkNumberRange additional check is only done when\n  // resulting value is an integer\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(`value ${valDec} can't safely be converted to number`, false, null, '42000', Errors.ER_PARSING_PRECISION);\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec.toString();\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec.toString();\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());\nconst readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;\nconst readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\nconst readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\nconst readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();","map":{"version":3,"names":["FieldType","require","Errors","BinaryDecoder","newRow","packet","columns","skip","readBuffer","Math","floor","length","castWrapper","column","opts","nullBitmap","index","string","isNullBitmap","readStringLengthEncoded","buffer","readBufferLengthEncoded","float","readFloat","tiny","signed","readInt8","readUInt8","short","readInt16","readUInt16","int","readInt32","long","readBigInt64","decimal","readDecimalLengthEncoded","date","readBinaryDate","datetime","readBinaryDateTime","geometry","defaultVal","dataTypeName","type","readGeometry","parser","col","columnType","TINY","readTinyBinarySigned","readTinyBinaryUnsigned","YEAR","SHORT","readShortBinarySigned","readShortBinaryUnsigned","INT24","readMediumBinarySigned","readMediumBinaryUnsigned","INT","readIntBinarySigned","readIntBinaryUnsigned","FLOAT","readFloatBinary","DOUBLE","readDoubleBinary","BIGINT","bigIntAsNumber","supportBigNumbers","readBigintAsIntBinarySigned","readBigintBinarySigned","readBigintAsIntBinaryUnsigned","readBigintBinaryUnsigned","DATE","readDateBinary","DATETIME","TIMESTAMP","dateStrings","readTimestampStringBinary","bind","scale","readTimestampBinary","TIME","readTimeBinary","DECIMAL","NEWDECIMAL","readDecimalAsIntBinary","readDecimalBinary","GEOMETRY","__getDefaultGeomVal","readGeometryBinary","JSON","readJsonBinary","BIT","columnLength","bitOneIsBoolean","readBitBinaryBoolean","readBinaryBuffer","dataTypeFormat","autoJsonMap","collation","isSet","readBinarySet","readStringBinary","module","exports","throwUnexpectedError","result","readInt24","readUInt32","readDouble","readBigUInt64","val","checkNumberRange","Number","isSafeInteger","ER_PARSING_PRECISION","bigNumberStrings","toString","readBinaryDateTimeAsString","readBinaryTime","valDec","decimalAsNumber","parse","split"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/cmd/decoder/binary-decoder.js"],"sourcesContent":["'use strict';\n\nconst FieldType = require('../../const/field-type');\nconst Errors = require('../../misc/errors');\n\nclass BinaryDecoder {\n  static newRow(packet, columns) {\n    packet.skip(1); // skip 0x00 header.\n    return packet.readBuffer(Math.floor((columns.length + 9) / 8));\n  }\n\n  static castWrapper(column, packet, opts, nullBitmap, index) {\n    column.string = () => (isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded());\n    column.buffer = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded());\n    column.float = () => (isNullBitmap(index, nullBitmap) ? null : packet.readFloat());\n    column.tiny = () =>\n      isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();\n    column.short = () =>\n      isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();\n    column.int = () => (isNullBitmap(index, nullBitmap) ? null : packet.readInt32());\n    column.long = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64());\n    column.decimal = () => (isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded());\n    column.date = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts));\n    column.datetime = () => (isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime());\n\n    column.geometry = () => {\n      let defaultVal = null;\n      if (column.dataTypeName) {\n        switch (column.dataTypeName) {\n          case 'point':\n            defaultVal = { type: 'Point' };\n            break;\n          case 'linestring':\n            defaultVal = { type: 'LineString' };\n            break;\n          case 'polygon':\n            defaultVal = { type: 'Polygon' };\n            break;\n          case 'multipoint':\n            defaultVal = { type: 'MultiPoint' };\n            break;\n          case 'multilinestring':\n            defaultVal = { type: 'MultiLineString' };\n            break;\n          case 'multipolygon':\n            defaultVal = { type: 'MultiPolygon' };\n            break;\n          default:\n            defaultVal = { type: column.dataTypeName };\n            break;\n        }\n      }\n\n      if (isNullBitmap(index, nullBitmap)) {\n        return defaultVal;\n      }\n      return packet.readGeometry(defaultVal);\n    };\n  }\n  static parser(col, opts) {\n    // set reader function read(col, packet, index, nullBitmap, opts, throwUnexpectedError)\n    // this permit for multi-row result-set to avoid resolving type parsing each data.\n    switch (col.columnType) {\n      case FieldType.TINY:\n        return col.signed() ? readTinyBinarySigned : readTinyBinaryUnsigned;\n\n      case FieldType.YEAR:\n      case FieldType.SHORT:\n        return col.signed() ? readShortBinarySigned : readShortBinaryUnsigned;\n\n      case FieldType.INT24:\n        return col.signed() ? readMediumBinarySigned : readMediumBinaryUnsigned;\n\n      case FieldType.INT:\n        return col.signed() ? readIntBinarySigned : readIntBinaryUnsigned;\n\n      case FieldType.FLOAT:\n        return readFloatBinary;\n\n      case FieldType.DOUBLE:\n        return readDoubleBinary;\n\n      case FieldType.BIGINT:\n        if (col.signed()) {\n          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;\n        }\n        return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;\n\n      case FieldType.DATE:\n        return readDateBinary;\n\n      case FieldType.DATETIME:\n      case FieldType.TIMESTAMP:\n        return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;\n\n      case FieldType.TIME:\n        return readTimeBinary;\n\n      case FieldType.DECIMAL:\n      case FieldType.NEWDECIMAL:\n        return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;\n\n      case FieldType.GEOMETRY:\n        let defaultVal = col.__getDefaultGeomVal();\n        return readGeometryBinary.bind(null, defaultVal);\n\n      case FieldType.JSON:\n        //for mysql only => parse string as JSON object\n        return readJsonBinary;\n\n      case FieldType.BIT:\n        if (col.columnLength === 1 && opts.bitOneIsBoolean) {\n          return readBitBinaryBoolean;\n        }\n        return readBinaryBuffer;\n\n      default:\n        if (col.dataTypeFormat && col.dataTypeFormat === 'json' && opts.autoJsonMap) {\n          return readJsonBinary;\n        }\n        if (col.collation.index === 63) {\n          return readBinaryBuffer;\n        }\n        if (col.isSet()) {\n          return readBinarySet;\n        }\n        return readStringBinary;\n    }\n  }\n}\nconst isNullBitmap = (index, nullBitmap) => {\n  return (nullBitmap[Math.floor((index + 2) / 8)] & (1 << (index + 2) % 8)) > 0;\n};\n\nmodule.exports = BinaryDecoder;\n\nconst readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt8();\nconst readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();\nconst readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt16();\nconst readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();\nconst readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return null;\n  }\n  const result = packet.readInt24();\n  packet.skip(1); // MEDIUMINT is encoded on 4 bytes in exchanges !\n  return result;\n};\nconst readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readInt32();\nconst readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();\nconst readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readFloat();\nconst readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readDouble();\nconst readBigintBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigUInt64();\n};\nconst readBigintBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  return packet.readBigInt64();\n};\n\nconst readBigintAsIntBinaryUnsigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigUInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(\n      `value ${val} can't safely be converted to number`,\n      false,\n      null,\n      '42000',\n      Errors.ER_PARSING_PRECISION\n    );\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\n\nconst readBigintAsIntBinarySigned = function (packet, opts, throwUnexpectedError, nullBitmap, index) {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const val = packet.readBigInt64();\n  if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {\n    return throwUnexpectedError(\n      `value ${val} can't safely be converted to number`,\n      false,\n      null,\n      '42000',\n      Errors.ER_PARSING_PRECISION\n    );\n  }\n  if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {\n    return val.toString();\n  }\n  return Number(val);\n};\n\nconst readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) {\n    return defaultVal;\n  }\n  return packet.readGeometry(defaultVal);\n};\nconst readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);\nconst readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();\nconst readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);\nconst readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();\nconst readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  //checkNumberRange additional check is only done when\n  // resulting value is an integer\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {\n      return throwUnexpectedError(\n        `value ${valDec} can't safely be converted to number`,\n        false,\n        null,\n        '42000',\n        Errors.ER_PARSING_PRECISION\n      );\n    }\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec.toString();\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const valDec = packet.readDecimalLengthEncoded();\n  if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {\n    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {\n      return valDec.toString();\n    }\n    return Number(valDec);\n  }\n  return valDec;\n};\nconst readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());\nconst readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;\nconst readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();\nconst readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {\n  if (isNullBitmap(index, nullBitmap)) return null;\n  const string = packet.readStringLengthEncoded();\n  return string == null ? null : string === '' ? [] : string.split(',');\n};\nconst readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) =>\n  isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,wBAAwB,CAAC;AACnD,MAAMC,MAAM,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AAE3C,MAAME,aAAa,CAAC;EAClB,OAAOC,MAAMA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC7BD,MAAM,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAChB,OAAOF,MAAM,CAACG,UAAU,CAACC,IAAI,CAACC,KAAK,CAAC,CAACJ,OAAO,CAACK,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;EAChE;EAEA,OAAOC,WAAWA,CAACC,MAAM,EAAER,MAAM,EAAES,IAAI,EAAEC,UAAU,EAAEC,KAAK,EAAE;IAC1DH,MAAM,CAACI,MAAM,GAAG,MAAOC,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACc,uBAAuB,EAAG;IACjGN,MAAM,CAACO,MAAM,GAAG,MAAOF,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACgB,uBAAuB,EAAG;IACjGR,MAAM,CAACS,KAAK,GAAG,MAAOJ,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACkB,SAAS,EAAG;IAClFV,MAAM,CAACW,IAAI,GAAG,MACZN,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGF,MAAM,CAACY,MAAM,EAAE,GAAGpB,MAAM,CAACqB,QAAQ,EAAE,GAAGrB,MAAM,CAACsB,SAAS,EAAE;IACnGd,MAAM,CAACe,KAAK,GAAG,MACbV,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGF,MAAM,CAACY,MAAM,EAAE,GAAGpB,MAAM,CAACwB,SAAS,EAAE,GAAGxB,MAAM,CAACyB,UAAU,EAAE;IACrGjB,MAAM,CAACkB,GAAG,GAAG,MAAOb,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAAC2B,SAAS,EAAG;IAChFnB,MAAM,CAACoB,IAAI,GAAG,MAAOf,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAAC6B,YAAY,EAAG;IACpFrB,MAAM,CAACsB,OAAO,GAAG,MAAOjB,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAAC+B,wBAAwB,EAAG;IACnGvB,MAAM,CAACwB,IAAI,GAAG,MAAOnB,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACiC,cAAc,CAACxB,IAAI,CAAE;IAC1FD,MAAM,CAAC0B,QAAQ,GAAG,MAAOrB,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACmC,kBAAkB,EAAG;IAE9F3B,MAAM,CAAC4B,QAAQ,GAAG,MAAM;MACtB,IAAIC,UAAU,GAAG,IAAI;MACrB,IAAI7B,MAAM,CAAC8B,YAAY,EAAE;QACvB,QAAQ9B,MAAM,CAAC8B,YAAY;UACzB,KAAK,OAAO;YACVD,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAQ,CAAC;YAC9B;UACF,KAAK,YAAY;YACfF,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAa,CAAC;YACnC;UACF,KAAK,SAAS;YACZF,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAU,CAAC;YAChC;UACF,KAAK,YAAY;YACfF,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAa,CAAC;YACnC;UACF,KAAK,iBAAiB;YACpBF,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAkB,CAAC;YACxC;UACF,KAAK,cAAc;YACjBF,UAAU,GAAG;cAAEE,IAAI,EAAE;YAAe,CAAC;YACrC;UACF;YACEF,UAAU,GAAG;cAAEE,IAAI,EAAE/B,MAAM,CAAC8B;YAAa,CAAC;YAC1C;QAAM;MAEZ;MAEA,IAAIzB,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE;QACnC,OAAO2B,UAAU;MACnB;MACA,OAAOrC,MAAM,CAACwC,YAAY,CAACH,UAAU,CAAC;IACxC,CAAC;EACH;EACA,OAAOI,MAAMA,CAACC,GAAG,EAAEjC,IAAI,EAAE;IACvB;IACA;IACA,QAAQiC,GAAG,CAACC,UAAU;MACpB,KAAKhD,SAAS,CAACiD,IAAI;QACjB,OAAOF,GAAG,CAACtB,MAAM,EAAE,GAAGyB,oBAAoB,GAAGC,sBAAsB;MAErE,KAAKnD,SAAS,CAACoD,IAAI;MACnB,KAAKpD,SAAS,CAACqD,KAAK;QAClB,OAAON,GAAG,CAACtB,MAAM,EAAE,GAAG6B,qBAAqB,GAAGC,uBAAuB;MAEvE,KAAKvD,SAAS,CAACwD,KAAK;QAClB,OAAOT,GAAG,CAACtB,MAAM,EAAE,GAAGgC,sBAAsB,GAAGC,wBAAwB;MAEzE,KAAK1D,SAAS,CAAC2D,GAAG;QAChB,OAAOZ,GAAG,CAACtB,MAAM,EAAE,GAAGmC,mBAAmB,GAAGC,qBAAqB;MAEnE,KAAK7D,SAAS,CAAC8D,KAAK;QAClB,OAAOC,eAAe;MAExB,KAAK/D,SAAS,CAACgE,MAAM;QACnB,OAAOC,gBAAgB;MAEzB,KAAKjE,SAAS,CAACkE,MAAM;QACnB,IAAInB,GAAG,CAACtB,MAAM,EAAE,EAAE;UAChB,OAAOX,IAAI,CAACqD,cAAc,IAAIrD,IAAI,CAACsD,iBAAiB,GAAGC,2BAA2B,GAAGC,sBAAsB;QAC7G;QACA,OAAOxD,IAAI,CAACqD,cAAc,IAAIrD,IAAI,CAACsD,iBAAiB,GAAGG,6BAA6B,GAAGC,wBAAwB;MAEjH,KAAKxE,SAAS,CAACyE,IAAI;QACjB,OAAOC,cAAc;MAEvB,KAAK1E,SAAS,CAAC2E,QAAQ;MACvB,KAAK3E,SAAS,CAAC4E,SAAS;QACtB,OAAO9D,IAAI,CAAC+D,WAAW,GAAGC,yBAAyB,CAACC,IAAI,CAAC,IAAI,EAAEhC,GAAG,CAACiC,KAAK,CAAC,GAAGC,mBAAmB;MAEjG,KAAKjF,SAAS,CAACkF,IAAI;QACjB,OAAOC,cAAc;MAEvB,KAAKnF,SAAS,CAACoF,OAAO;MACtB,KAAKpF,SAAS,CAACqF,UAAU;QACvB,OAAOtC,GAAG,CAACiC,KAAK,KAAK,CAAC,GAAGM,sBAAsB,GAAGC,iBAAiB;MAErE,KAAKvF,SAAS,CAACwF,QAAQ;QACrB,IAAI9C,UAAU,GAAGK,GAAG,CAAC0C,mBAAmB,EAAE;QAC1C,OAAOC,kBAAkB,CAACX,IAAI,CAAC,IAAI,EAAErC,UAAU,CAAC;MAElD,KAAK1C,SAAS,CAAC2F,IAAI;QACjB;QACA,OAAOC,cAAc;MAEvB,KAAK5F,SAAS,CAAC6F,GAAG;QAChB,IAAI9C,GAAG,CAAC+C,YAAY,KAAK,CAAC,IAAIhF,IAAI,CAACiF,eAAe,EAAE;UAClD,OAAOC,oBAAoB;QAC7B;QACA,OAAOC,gBAAgB;MAEzB;QACE,IAAIlD,GAAG,CAACmD,cAAc,IAAInD,GAAG,CAACmD,cAAc,KAAK,MAAM,IAAIpF,IAAI,CAACqF,WAAW,EAAE;UAC3E,OAAOP,cAAc;QACvB;QACA,IAAI7C,GAAG,CAACqD,SAAS,CAACpF,KAAK,KAAK,EAAE,EAAE;UAC9B,OAAOiF,gBAAgB;QACzB;QACA,IAAIlD,GAAG,CAACsD,KAAK,EAAE,EAAE;UACf,OAAOC,aAAa;QACtB;QACA,OAAOC,gBAAgB;IAAC;EAE9B;AACF;AACA,MAAMrF,YAAY,GAAGA,CAACF,KAAK,EAAED,UAAU,KAAK;EAC1C,OAAO,CAACA,UAAU,CAACN,IAAI,CAACC,KAAK,CAAC,CAACM,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAI,CAAC,IAAI,CAACA,KAAK,GAAG,CAAC,IAAI,CAAE,IAAI,CAAC;AAC/E,CAAC;AAEDwF,MAAM,CAACC,OAAO,GAAGtG,aAAa;AAE9B,MAAM+C,oBAAoB,GAAGA,CAAC7C,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KACjFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACqB,QAAQ,EAAE;AAC5D,MAAMyB,sBAAsB,GAAGA,CAAC9C,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KACnFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACsB,SAAS,EAAE;AAC7D,MAAM2B,qBAAqB,GAAGA,CAACjD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAClFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACwB,SAAS,EAAE;AAC7D,MAAM0B,uBAAuB,GAAGA,CAAClD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KACpFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACyB,UAAU,EAAE;AAC9D,MAAM2B,sBAAsB,GAAGA,CAACpD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EACxF,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE;IACnC,OAAO,IAAI;EACb;EACA,MAAM4F,MAAM,GAAGtG,MAAM,CAACuG,SAAS,EAAE;EACjCvG,MAAM,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAChB,OAAOoG,MAAM;AACf,CAAC;AACD,MAAMjD,wBAAwB,GAAGA,CAACrD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EAC1F,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE;IACnC,OAAO,IAAI;EACb;EACA,MAAM4F,MAAM,GAAGtG,MAAM,CAACuG,SAAS,EAAE;EACjCvG,MAAM,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAChB,OAAOoG,MAAM;AACf,CAAC;AACD,MAAM/C,mBAAmB,GAAGA,CAACvD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAChFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAAC2B,SAAS,EAAE;AAC7D,MAAM6B,qBAAqB,GAAGA,CAACxD,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAClFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACwG,UAAU,EAAE;AAC9D,MAAM9C,eAAe,GAAGA,CAAC1D,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC5EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACkB,SAAS,EAAE;AAC7D,MAAM0C,gBAAgB,GAAGA,CAAC5D,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC7EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACyG,UAAU,EAAE;AAC9D,MAAMtC,wBAAwB,GAAG,SAAAA,CAAUnE,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,EAAE;EAChG,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,OAAOV,MAAM,CAAC0G,aAAa,EAAE;AAC/B,CAAC;AACD,MAAMzC,sBAAsB,GAAG,SAAAA,CAAUjE,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,EAAE;EAC9F,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,OAAOV,MAAM,CAAC6B,YAAY,EAAE;AAC9B,CAAC;AAED,MAAMqC,6BAA6B,GAAG,SAAAA,CAAUlE,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,EAAE;EACrG,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,MAAMiG,GAAG,GAAG3G,MAAM,CAAC0G,aAAa,EAAE;EAClC,IAAIjG,IAAI,CAACqD,cAAc,IAAIrD,IAAI,CAACmG,gBAAgB,IAAI,CAACC,MAAM,CAACC,aAAa,CAACD,MAAM,CAACF,GAAG,CAAC,CAAC,EAAE;IACtF,OAAON,oBAAoB,CACxB,SAAQM,GAAI,sCAAqC,EAClD,KAAK,EACL,IAAI,EACJ,OAAO,EACP9G,MAAM,CAACkH,oBAAoB,CAC5B;EACH;EACA,IAAItG,IAAI,CAACsD,iBAAiB,KAAKtD,IAAI,CAACuG,gBAAgB,IAAI,CAACH,MAAM,CAACC,aAAa,CAACD,MAAM,CAACF,GAAG,CAAC,CAAC,CAAC,EAAE;IAC3F,OAAOA,GAAG,CAACM,QAAQ,EAAE;EACvB;EACA,OAAOJ,MAAM,CAACF,GAAG,CAAC;AACpB,CAAC;AAED,MAAM3C,2BAA2B,GAAG,SAAAA,CAAUhE,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,EAAE;EACnG,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,MAAMiG,GAAG,GAAG3G,MAAM,CAAC6B,YAAY,EAAE;EACjC,IAAIpB,IAAI,CAACqD,cAAc,IAAIrD,IAAI,CAACmG,gBAAgB,IAAI,CAACC,MAAM,CAACC,aAAa,CAACD,MAAM,CAACF,GAAG,CAAC,CAAC,EAAE;IACtF,OAAON,oBAAoB,CACxB,SAAQM,GAAI,sCAAqC,EAClD,KAAK,EACL,IAAI,EACJ,OAAO,EACP9G,MAAM,CAACkH,oBAAoB,CAC5B;EACH;EACA,IAAItG,IAAI,CAACsD,iBAAiB,KAAKtD,IAAI,CAACuG,gBAAgB,IAAI,CAACH,MAAM,CAACC,aAAa,CAACD,MAAM,CAACF,GAAG,CAAC,CAAC,CAAC,EAAE;IAC3F,OAAOA,GAAG,CAACM,QAAQ,EAAE;EACvB;EACA,OAAOJ,MAAM,CAACF,GAAG,CAAC;AACpB,CAAC;AAED,MAAMtB,kBAAkB,GAAGA,CAAChD,UAAU,EAAErC,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EAChG,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE;IACnC,OAAO2B,UAAU;EACnB;EACA,OAAOrC,MAAM,CAACwC,YAAY,CAACH,UAAU,CAAC;AACxC,CAAC;AACD,MAAMgC,cAAc,GAAGA,CAACrE,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC3EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACiC,cAAc,CAACxB,IAAI,CAAC;AACtE,MAAMmE,mBAAmB,GAAGA,CAAC5E,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAChFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACmC,kBAAkB,EAAE;AACtE,MAAMsC,yBAAyB,GAAGA,CAACE,KAAK,EAAE3E,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC7FE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACkH,0BAA0B,CAACvC,KAAK,CAAC;AACnF,MAAMG,cAAc,GAAGA,CAAC9E,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC3EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACmH,cAAc,EAAE;AAClE,MAAMlC,sBAAsB,GAAGA,CAACjF,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EACxF;EACA;EACA,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,MAAM0G,MAAM,GAAGpH,MAAM,CAAC+B,wBAAwB,EAAE;EAChD,IAAIqF,MAAM,IAAI,IAAI,KAAK3G,IAAI,CAAC4G,eAAe,IAAI5G,IAAI,CAACsD,iBAAiB,CAAC,EAAE;IACtE,IAAItD,IAAI,CAAC4G,eAAe,IAAI5G,IAAI,CAACmG,gBAAgB,IAAI,CAACC,MAAM,CAACC,aAAa,CAACD,MAAM,CAACO,MAAM,CAAC,CAAC,EAAE;MAC1F,OAAOf,oBAAoB,CACxB,SAAQe,MAAO,sCAAqC,EACrD,KAAK,EACL,IAAI,EACJ,OAAO,EACPvH,MAAM,CAACkH,oBAAoB,CAC5B;IACH;IACA,IAAItG,IAAI,CAACsD,iBAAiB,KAAKtD,IAAI,CAACuG,gBAAgB,IAAI,CAACH,MAAM,CAACC,aAAa,CAACD,MAAM,CAACO,MAAM,CAAC,CAAC,CAAC,EAAE;MAC9F,OAAOA,MAAM,CAACH,QAAQ,EAAE;IAC1B;IACA,OAAOJ,MAAM,CAACO,MAAM,CAAC;EACvB;EACA,OAAOA,MAAM;AACf,CAAC;AACD,MAAMlC,iBAAiB,GAAGA,CAAClF,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EACnF,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,MAAM0G,MAAM,GAAGpH,MAAM,CAAC+B,wBAAwB,EAAE;EAChD,IAAIqF,MAAM,IAAI,IAAI,KAAK3G,IAAI,CAAC4G,eAAe,IAAI5G,IAAI,CAACsD,iBAAiB,CAAC,EAAE;IACtE,IAAItD,IAAI,CAACsD,iBAAiB,KAAKtD,IAAI,CAACuG,gBAAgB,IAAI,CAACH,MAAM,CAACC,aAAa,CAACD,MAAM,CAACO,MAAM,CAAC,CAAC,CAAC,EAAE;MAC9F,OAAOA,MAAM,CAACH,QAAQ,EAAE;IAC1B;IACA,OAAOJ,MAAM,CAACO,MAAM,CAAC;EACvB;EACA,OAAOA,MAAM;AACf,CAAC;AACD,MAAM7B,cAAc,GAAGA,CAACvF,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC3EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAG4E,IAAI,CAACgC,KAAK,CAACtH,MAAM,CAACc,uBAAuB,EAAE,CAAC;AACvF,MAAM6E,oBAAoB,GAAGA,CAAC3F,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KACjFE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACgB,uBAAuB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;AACpF,MAAM4E,gBAAgB,GAAGA,CAAC5F,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC7EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACgB,uBAAuB,EAAE;AAC3E,MAAMiF,aAAa,GAAGA,CAACjG,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAAK;EAC/E,IAAIE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;EAChD,MAAME,MAAM,GAAGZ,MAAM,CAACc,uBAAuB,EAAE;EAC/C,OAAOF,MAAM,IAAI,IAAI,GAAG,IAAI,GAAGA,MAAM,KAAK,EAAE,GAAG,EAAE,GAAGA,MAAM,CAAC2G,KAAK,CAAC,GAAG,CAAC;AACvE,CAAC;AACD,MAAMrB,gBAAgB,GAAGA,CAAClG,MAAM,EAAES,IAAI,EAAE4F,oBAAoB,EAAE3F,UAAU,EAAEC,KAAK,KAC7EE,YAAY,CAACF,KAAK,EAAED,UAAU,CAAC,GAAG,IAAI,GAAGV,MAAM,CAACc,uBAAuB,EAAE"},"metadata":{},"sourceType":"script","externalDependencies":[]}