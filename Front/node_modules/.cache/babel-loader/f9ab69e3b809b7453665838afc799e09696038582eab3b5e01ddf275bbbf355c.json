{"ast":null,"code":"'use strict';\n\nconst Parser = require('./parser');\nconst Errors = require('../misc/errors');\nconst BinaryEncoder = require('./encoder/binary-encoder');\nconst FieldType = require('../const/field-type');\nconst OkPacket = require('./class/ok-packet');\n\n/**\n * Protocol COM_STMT_BULK_EXECUTE\n * see : https://mariadb.com/kb/en/library/com_stmt_bulk_execute/\n */\nclass BatchBulk extends Parser {\n  constructor(resolve, reject, connOpts, prepare, cmdParam) {\n    super(resolve, reject, connOpts, cmdParam);\n    this.encoder = new BinaryEncoder(this.opts);\n    this.cmdOpts = cmdParam.opts;\n    this.binary = true;\n    this.prepare = prepare;\n    this.canSkipMeta = true;\n  }\n\n  /**\n   * Send COM_STMT_BULK_EXECUTE\n   *\n   * @param out   output writer\n   * @param opts  connection options\n   * @param info  connection information\n   */\n  start(out, opts, info) {\n    this.info = info;\n    this.values = this.initialValues;\n    if (this.cmdOpts && this.cmdOpts.timeout) {\n      this.bulkPacketNo = 1;\n      this.sending = false;\n      const err = Errors.createError('Cannot use timeout for Batch statement', Errors.ER_TIMEOUT_NOT_SUPPORTED, info, 'HY000', this.sql);\n      this.emit('send_end');\n      this.throwError(err, info);\n      return;\n    }\n    this.onPacketReceive = this.readResponsePacket;\n    if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {\n      // using named placeholders, so change values accordingly\n      this.values = [];\n      if (this.initialValues) {\n        for (let r = 0; r < this.initialValues.length; r++) {\n          let val = this.initialValues[r];\n          this.values[r] = new Array(this.prepare.parameterCount);\n          for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {\n            this.values[r][i] = val[this.prepare._placeHolderIndex[i]];\n          }\n        }\n      }\n    } else {\n      this.values = this.initialValues;\n    }\n    if (!this.validateParameters(info)) return;\n    this.sendComStmtBulkExecute(out, opts, info);\n  }\n\n  /**\n   * Set header type\n   * @param value current value\n   * @param parameterCount parameter number\n   * @returns {*[]} header type array\n   */\n  parameterHeaderFromValue(value, parameterCount) {\n    const parameterHeaderType = new Array(parameterCount);\n\n    // set header type\n    for (let i = 0; i < parameterCount; i++) {\n      const val = value[i];\n      if (val != null) {\n        switch (typeof val) {\n          case 'boolean':\n            parameterHeaderType[i] = FieldType.TINY;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              parameterHeaderType[i] = FieldType.NEWDECIMAL;\n            } else {\n              parameterHeaderType[i] = FieldType.BIGINT;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              parameterHeaderType[i] = FieldType.INT;\n              break;\n            }\n            parameterHeaderType[i] = FieldType.DOUBLE;\n            break;\n          case 'string':\n            parameterHeaderType[i] = FieldType.VAR_STRING;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              parameterHeaderType[i] = FieldType.TIMESTAMP;\n            } else if (Buffer.isBuffer(val)) {\n              parameterHeaderType[i] = FieldType.BLOB;\n            } else if (typeof val.toSqlString === 'function') {\n              parameterHeaderType[i] = FieldType.VAR_STRING;\n            } else {\n              if (val.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(val.type)) {\n                parameterHeaderType[i] = FieldType.BLOB;\n              } else {\n                parameterHeaderType[i] = FieldType.VAR_STRING;\n              }\n            }\n            break;\n          default:\n            parameterHeaderType[i] = FieldType.BLOB;\n            break;\n        }\n      } else {\n        parameterHeaderType[i] = FieldType.VAR_STRING;\n      }\n    }\n    return parameterHeaderType;\n  }\n\n  /**\n   * Check current value has same header than set in initial BULK header\n   *\n   * @param parameterHeaderType current header\n   * @param value current value\n   * @param parameterCount number of parameter\n   * @returns {boolean} true if identical\n   */\n  checkSameHeader(parameterHeaderType, value, parameterCount) {\n    // set header type\n    let val;\n    for (let i = 0; i < parameterCount; i++) {\n      if ((val = value[i]) != null) {\n        switch (typeof val) {\n          case 'boolean':\n            if (parameterHeaderType[i] !== FieldType.TINY) return false;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (parameterHeaderType[i] !== FieldType.BIGINT) return false;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              if (parameterHeaderType[i] !== FieldType.INT) return false;\n              break;\n            }\n            if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;\n            break;\n          case 'string':\n            if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;\n            } else if (Buffer.isBuffer(val)) {\n              if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            } else if (typeof val.toSqlString === 'function') {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (val.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(val.type)) {\n                if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n              } else {\n                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n              }\n            }\n            break;\n          default:\n            if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            break;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Send a COM_STMT_BULK_EXECUTE\n   * @param out output packet writer\n   * @param opts options\n   * @param info information\n   */\n  sendComStmtBulkExecute(out, opts, info) {\n    if (opts.logger.query) opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logger.logParam ? this.displaySql() : this.sql}`);\n    const parameterCount = this.prepare.parameterCount;\n    this.rowIdx = 0;\n    this.vals = this.values[this.rowIdx++];\n    let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n    let lastCmdData = null;\n    this.bulkPacketNo = 0;\n    this.sending = true;\n\n    /**\n     * Implementation After writing bunch of parameter to buffer is marked. then : - when writing\n     * next bunch of parameter, if buffer grow more than max_allowed_packet, send buffer up to mark,\n     * then create a new packet with current bunch of data - if bunch of parameter data type changes\n     * send buffer up to mark, then create a new packet with new data type.\n     *\n     * <p>Problem remains if a bunch of parameter is bigger than max_allowed_packet\n     */\n    main_loop: while (true) {\n      this.bulkPacketNo++;\n      out.startPacket(this);\n      out.writeInt8(0xfa); // COM_STMT_BULK_EXECUTE\n      out.writeInt32(this.prepare.id); // Statement id\n      out.writeInt16(128); // always SEND_TYPES_TO_SERVER\n\n      for (let i = 0; i < parameterCount; i++) {\n        out.writeInt16(parameterHeaderType[i]);\n      }\n      if (lastCmdData != null) {\n        const err = out.checkMaxAllowedLength(lastCmdData.length, info);\n        if (err) {\n          this.throwError(err, info);\n          return;\n        }\n        out.writeBuffer(lastCmdData, 0, lastCmdData.length);\n        out.mark();\n        lastCmdData = null;\n        if (!this.rowIdx >= this.values.length) {\n          break;\n        }\n        this.vals = this.values[this.rowIdx++];\n      }\n      parameter_loop: while (true) {\n        for (let i = 0; i < parameterCount; i++) {\n          let param = this.vals[i];\n          if (param !== null) {\n            // special check for GEOJSON that can be null even if object is not\n            if (param.type != null && ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'].includes(param.type)) {\n              const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);\n              if (geoBuff == null) {\n                out.writeInt8(0x01); // value is null\n              } else {\n                out.writeInt8(0x00); // value follow\n                param = Buffer.concat([Buffer.from([0, 0, 0, 0]),\n                // SRID\n                geoBuff // WKB\n                ]);\n\n                this.encoder.writeParam(out, param, this.opts, info);\n              }\n            } else {\n              out.writeInt8(0x00); // value follow\n              this.encoder.writeParam(out, param, this.opts, info);\n            }\n          } else {\n            out.writeInt8(0x01); // value is null\n          }\n        }\n\n        if (!out.bufIsDataAfterMark() && !out.isMarked() && out.hasFlushed()) {\n          // parameter were too big to fit in a MySQL packet\n          // need to finish the packet separately\n          out.flush();\n          if (!this.rowIdx >= this.values.length) {\n            break main_loop;\n          }\n          this.vals = this.values[this.rowIdx++];\n\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n        if (out.isMarked() && out.bufIsAfterMaxPacketLength()) {\n          // for max_allowed_packet < 16Mb\n          // packet length was ok at last mark, but won't with new data\n          out.flushBufferStopAtMark();\n          out.mark();\n          lastCmdData = out.resetMark();\n          break;\n        }\n        out.mark();\n        if (out.bufIsDataAfterMark()) {\n          // flush has been done\n          lastCmdData = out.resetMark();\n          break;\n        }\n        if (this.rowIdx >= this.values.length) {\n          break main_loop;\n        }\n        this.vals = this.values[this.rowIdx++];\n\n        // ensure type has not changed\n        if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {\n          out.flush();\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n      }\n    }\n    out.flush();\n    this.sending = false;\n    this.emit('send_end');\n  }\n  displaySql() {\n    if (this.sql.length > this.opts.debugLen) {\n      return this.sql.substring(0, this.opts.debugLen) + '...';\n    }\n    let sqlMsg = this.sql + ' - parameters:';\n    sqlMsg += '[';\n    for (let i = 0; i < this.initialValues.length; i++) {\n      if (i !== 0) sqlMsg += ',';\n      let param = this.initialValues[i];\n      sqlMsg = this.logParameters(sqlMsg, param);\n      if (sqlMsg.length > this.opts.debugLen) {\n        sqlMsg = sqlMsg.substring(0, this.opts.debugLen) + '...';\n        break;\n      }\n    }\n    sqlMsg += ']';\n    return sqlMsg;\n  }\n  success(val) {\n    this.bulkPacketNo--;\n    if (val instanceof OkPacket) this._rows.push(val);\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.packet = null;\n      if (this.firstError) {\n        this.resolve = null;\n        this.onPacketReceive = null;\n        this._columns = null;\n        this._rows = null;\n        process.nextTick(this.reject, this.firstError);\n        this.reject = null;\n        this.emit('end', this.firstError);\n      } else {\n        if (this._rows[0].affectedRows !== undefined) {\n          // ok packets, reassemble them if needed\n          let totalAffectedRows = 0;\n          this._rows.forEach(row => {\n            totalAffectedRows += row.affectedRows;\n          });\n          const rs = new OkPacket(totalAffectedRows, this._rows[0].insertId, this._rows[this._rows.length - 1].warningStatus);\n          this.successEnd(rs);\n        } else {\n          // insert with returning\n          if (this._rows.length === 1) {\n            this.successEnd(this._rows[0]);\n          } else {\n            const rs = [];\n            rs.meta = this._rows[0].meta;\n            this._rows.forEach(row => {\n              Array.prototype.push.apply(rs, row);\n            });\n            rs.meta = this._rows[0].meta;\n            this.successEnd(rs);\n          }\n        }\n        this._columns = null;\n        this._rows = null;\n      }\n      return;\n    }\n    if (!this.firstError) {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n  throwError(err, info) {\n    this.bulkPacketNo--;\n    if (!this.firstError) {\n      if (err.fatal) {\n        this.bulkPacketNo = 0;\n      }\n      if (this.stack) {\n        err = Errors.createError(err.message, err.errno, info, err.sqlState, this.sql, err.fatal, this.stack, false);\n      }\n      this.firstError = err;\n    }\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.resolve = null;\n      this.emit('send_end');\n      process.nextTick(this.reject, this.firstError);\n      this.reject = null;\n      this.onPacketReceive = null;\n      this.emit('end', this.firstError);\n    } else {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  /**\n   * Validate that parameters exists and are defined.\n   *\n   * @param info        connection info\n   * @returns {boolean} return false if any error occur.\n   */\n  validateParameters(info) {\n    //validate parameter size.\n    const nbParameter = this.prepare.parameterCount;\n    for (let r = 0; r < this.values.length; r++) {\n      if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];\n\n      //validate parameter is defined.\n      for (let i = 0; i < nbParameter; i++) {\n        if (this.values[r][i] === undefined) {\n          this.emit('send_end');\n          this.throwNewError(`Parameter at position ${i} is not set for values ${r}\\n ${this.displaySql()}`, false, info, 'HY000', Errors.ER_PARAMETER_UNDEFINED);\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\nmodule.exports = BatchBulk;","map":{"version":3,"names":["Parser","require","Errors","BinaryEncoder","FieldType","OkPacket","BatchBulk","constructor","resolve","reject","connOpts","prepare","cmdParam","encoder","opts","cmdOpts","binary","canSkipMeta","start","out","info","values","initialValues","timeout","bulkPacketNo","sending","err","createError","ER_TIMEOUT_NOT_SUPPORTED","sql","emit","throwError","onPacketReceive","readResponsePacket","namedPlaceholders","_placeHolderIndex","r","length","val","Array","parameterCount","i","validateParameters","sendComStmtBulkExecute","parameterHeaderFromValue","value","parameterHeaderType","TINY","NEWDECIMAL","BIGINT","Number","isSafeInteger","INT","DOUBLE","VAR_STRING","Date","TIMESTAMP","Buffer","isBuffer","BLOB","toSqlString","type","includes","checkSameHeader","logger","query","id","logParam","displaySql","rowIdx","vals","lastCmdData","main_loop","startPacket","writeInt8","writeInt32","writeInt16","checkMaxAllowedLength","writeBuffer","mark","parameter_loop","param","geoBuff","getBufferFromGeometryValue","concat","from","writeParam","bufIsDataAfterMark","isMarked","hasFlushed","flush","bufIsAfterMaxPacketLength","flushBufferStopAtMark","resetMark","debugLen","substring","sqlMsg","logParameters","success","_rows","push","packet","firstError","_columns","process","nextTick","affectedRows","undefined","totalAffectedRows","forEach","row","rs","insertId","warningStatus","successEnd","meta","prototype","apply","_responseIndex","fatal","stack","message","errno","sqlState","nbParameter","isArray","throwNewError","ER_PARAMETER_UNDEFINED","module","exports"],"sources":["/home/warameur/Documents/velocity-data-viz/node_modules/mariadb/lib/cmd/batch-bulk.js"],"sourcesContent":["'use strict';\n\nconst Parser = require('./parser');\nconst Errors = require('../misc/errors');\nconst BinaryEncoder = require('./encoder/binary-encoder');\nconst FieldType = require('../const/field-type');\nconst OkPacket = require('./class/ok-packet');\n\n/**\n * Protocol COM_STMT_BULK_EXECUTE\n * see : https://mariadb.com/kb/en/library/com_stmt_bulk_execute/\n */\nclass BatchBulk extends Parser {\n  constructor(resolve, reject, connOpts, prepare, cmdParam) {\n    super(resolve, reject, connOpts, cmdParam);\n    this.encoder = new BinaryEncoder(this.opts);\n    this.cmdOpts = cmdParam.opts;\n    this.binary = true;\n    this.prepare = prepare;\n    this.canSkipMeta = true;\n  }\n\n  /**\n   * Send COM_STMT_BULK_EXECUTE\n   *\n   * @param out   output writer\n   * @param opts  connection options\n   * @param info  connection information\n   */\n  start(out, opts, info) {\n    this.info = info;\n    this.values = this.initialValues;\n\n    if (this.cmdOpts && this.cmdOpts.timeout) {\n      this.bulkPacketNo = 1;\n      this.sending = false;\n      const err = Errors.createError(\n        'Cannot use timeout for Batch statement',\n        Errors.ER_TIMEOUT_NOT_SUPPORTED,\n        info,\n        'HY000',\n        this.sql\n      );\n      this.emit('send_end');\n      this.throwError(err, info);\n      return;\n    }\n    this.onPacketReceive = this.readResponsePacket;\n    if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {\n      // using named placeholders, so change values accordingly\n      this.values = [];\n      if (this.initialValues) {\n        for (let r = 0; r < this.initialValues.length; r++) {\n          let val = this.initialValues[r];\n          this.values[r] = new Array(this.prepare.parameterCount);\n          for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {\n            this.values[r][i] = val[this.prepare._placeHolderIndex[i]];\n          }\n        }\n      }\n    } else {\n      this.values = this.initialValues;\n    }\n\n    if (!this.validateParameters(info)) return;\n\n    this.sendComStmtBulkExecute(out, opts, info);\n  }\n\n  /**\n   * Set header type\n   * @param value current value\n   * @param parameterCount parameter number\n   * @returns {*[]} header type array\n   */\n  parameterHeaderFromValue(value, parameterCount) {\n    const parameterHeaderType = new Array(parameterCount);\n\n    // set header type\n    for (let i = 0; i < parameterCount; i++) {\n      const val = value[i];\n      if (val != null) {\n        switch (typeof val) {\n          case 'boolean':\n            parameterHeaderType[i] = FieldType.TINY;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              parameterHeaderType[i] = FieldType.NEWDECIMAL;\n            } else {\n              parameterHeaderType[i] = FieldType.BIGINT;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              parameterHeaderType[i] = FieldType.INT;\n              break;\n            }\n            parameterHeaderType[i] = FieldType.DOUBLE;\n            break;\n          case 'string':\n            parameterHeaderType[i] = FieldType.VAR_STRING;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              parameterHeaderType[i] = FieldType.TIMESTAMP;\n            } else if (Buffer.isBuffer(val)) {\n              parameterHeaderType[i] = FieldType.BLOB;\n            } else if (typeof val.toSqlString === 'function') {\n              parameterHeaderType[i] = FieldType.VAR_STRING;\n            } else {\n              if (\n                val.type != null &&\n                [\n                  'Point',\n                  'LineString',\n                  'Polygon',\n                  'MultiPoint',\n                  'MultiLineString',\n                  'MultiPolygon',\n                  'GeometryCollection'\n                ].includes(val.type)\n              ) {\n                parameterHeaderType[i] = FieldType.BLOB;\n              } else {\n                parameterHeaderType[i] = FieldType.VAR_STRING;\n              }\n            }\n            break;\n          default:\n            parameterHeaderType[i] = FieldType.BLOB;\n            break;\n        }\n      } else {\n        parameterHeaderType[i] = FieldType.VAR_STRING;\n      }\n    }\n    return parameterHeaderType;\n  }\n\n  /**\n   * Check current value has same header than set in initial BULK header\n   *\n   * @param parameterHeaderType current header\n   * @param value current value\n   * @param parameterCount number of parameter\n   * @returns {boolean} true if identical\n   */\n  checkSameHeader(parameterHeaderType, value, parameterCount) {\n    // set header type\n    let val;\n    for (let i = 0; i < parameterCount; i++) {\n      if ((val = value[i]) != null) {\n        switch (typeof val) {\n          case 'boolean':\n            if (parameterHeaderType[i] !== FieldType.TINY) return false;\n            break;\n          case 'bigint':\n            if (val >= 2n ** 63n) {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (parameterHeaderType[i] !== FieldType.BIGINT) return false;\n            }\n            break;\n          case 'number':\n            // additional verification, to permit query without type,\n            // like 'SELECT ?' returning same type of value\n            if (Number.isSafeInteger(val) && val >= -2147483648 && val < 2147483647) {\n              if (parameterHeaderType[i] !== FieldType.INT) return false;\n              break;\n            }\n            if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;\n            break;\n          case 'string':\n            if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            break;\n          case 'object':\n            if (val instanceof Date) {\n              if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;\n            } else if (Buffer.isBuffer(val)) {\n              if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            } else if (typeof val.toSqlString === 'function') {\n              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n            } else {\n              if (\n                val.type != null &&\n                [\n                  'Point',\n                  'LineString',\n                  'Polygon',\n                  'MultiPoint',\n                  'MultiLineString',\n                  'MultiPolygon',\n                  'GeometryCollection'\n                ].includes(val.type)\n              ) {\n                if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n              } else {\n                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;\n              }\n            }\n            break;\n          default:\n            if (parameterHeaderType[i] !== FieldType.BLOB) return false;\n            break;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Send a COM_STMT_BULK_EXECUTE\n   * @param out output packet writer\n   * @param opts options\n   * @param info information\n   */\n  sendComStmtBulkExecute(out, opts, info) {\n    if (opts.logger.query)\n      opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logger.logParam ? this.displaySql() : this.sql}`);\n    const parameterCount = this.prepare.parameterCount;\n    this.rowIdx = 0;\n    this.vals = this.values[this.rowIdx++];\n    let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n    let lastCmdData = null;\n    this.bulkPacketNo = 0;\n    this.sending = true;\n\n    /**\n     * Implementation After writing bunch of parameter to buffer is marked. then : - when writing\n     * next bunch of parameter, if buffer grow more than max_allowed_packet, send buffer up to mark,\n     * then create a new packet with current bunch of data - if bunch of parameter data type changes\n     * send buffer up to mark, then create a new packet with new data type.\n     *\n     * <p>Problem remains if a bunch of parameter is bigger than max_allowed_packet\n     */\n    main_loop: while (true) {\n      this.bulkPacketNo++;\n      out.startPacket(this);\n      out.writeInt8(0xfa); // COM_STMT_BULK_EXECUTE\n      out.writeInt32(this.prepare.id); // Statement id\n      out.writeInt16(128); // always SEND_TYPES_TO_SERVER\n\n      for (let i = 0; i < parameterCount; i++) {\n        out.writeInt16(parameterHeaderType[i]);\n      }\n\n      if (lastCmdData != null) {\n        const err = out.checkMaxAllowedLength(lastCmdData.length, info);\n        if (err) {\n          this.throwError(err, info);\n          return;\n        }\n        out.writeBuffer(lastCmdData, 0, lastCmdData.length);\n        out.mark();\n        lastCmdData = null;\n        if (!this.rowIdx >= this.values.length) {\n          break;\n        }\n        this.vals = this.values[this.rowIdx++];\n      }\n\n      parameter_loop: while (true) {\n        for (let i = 0; i < parameterCount; i++) {\n          let param = this.vals[i];\n          if (param !== null) {\n            // special check for GEOJSON that can be null even if object is not\n            if (\n              param.type != null &&\n              [\n                'Point',\n                'LineString',\n                'Polygon',\n                'MultiPoint',\n                'MultiLineString',\n                'MultiPolygon',\n                'GeometryCollection'\n              ].includes(param.type)\n            ) {\n              const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);\n              if (geoBuff == null) {\n                out.writeInt8(0x01); // value is null\n              } else {\n                out.writeInt8(0x00); // value follow\n                param = Buffer.concat([\n                  Buffer.from([0, 0, 0, 0]), // SRID\n                  geoBuff // WKB\n                ]);\n                this.encoder.writeParam(out, param, this.opts, info);\n              }\n            } else {\n              out.writeInt8(0x00); // value follow\n              this.encoder.writeParam(out, param, this.opts, info);\n            }\n          } else {\n            out.writeInt8(0x01); // value is null\n          }\n        }\n\n        if (!out.bufIsDataAfterMark() && !out.isMarked() && out.hasFlushed()) {\n          // parameter were too big to fit in a MySQL packet\n          // need to finish the packet separately\n          out.flush();\n          if (!this.rowIdx >= this.values.length) {\n            break main_loop;\n          }\n          this.vals = this.values[this.rowIdx++];\n\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n\n        if (out.isMarked() && out.bufIsAfterMaxPacketLength()) {\n          // for max_allowed_packet < 16Mb\n          // packet length was ok at last mark, but won't with new data\n          out.flushBufferStopAtMark();\n          out.mark();\n          lastCmdData = out.resetMark();\n          break;\n        }\n\n        out.mark();\n\n        if (out.bufIsDataAfterMark()) {\n          // flush has been done\n          lastCmdData = out.resetMark();\n          break;\n        }\n\n        if (this.rowIdx >= this.values.length) {\n          break main_loop;\n        }\n\n        this.vals = this.values[this.rowIdx++];\n\n        // ensure type has not changed\n        if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {\n          out.flush();\n          // reset header type\n          parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);\n          break parameter_loop;\n        }\n      }\n    }\n    out.flush();\n    this.sending = false;\n    this.emit('send_end');\n  }\n\n  displaySql() {\n    if (this.sql.length > this.opts.debugLen) {\n      return this.sql.substring(0, this.opts.debugLen) + '...';\n    }\n\n    let sqlMsg = this.sql + ' - parameters:';\n    sqlMsg += '[';\n    for (let i = 0; i < this.initialValues.length; i++) {\n      if (i !== 0) sqlMsg += ',';\n      let param = this.initialValues[i];\n      sqlMsg = this.logParameters(sqlMsg, param);\n      if (sqlMsg.length > this.opts.debugLen) {\n        sqlMsg = sqlMsg.substring(0, this.opts.debugLen) + '...';\n        break;\n      }\n    }\n    sqlMsg += ']';\n    return sqlMsg;\n  }\n\n  success(val) {\n    this.bulkPacketNo--;\n    if (val instanceof OkPacket) this._rows.push(val);\n\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.packet = null;\n      if (this.firstError) {\n        this.resolve = null;\n        this.onPacketReceive = null;\n        this._columns = null;\n        this._rows = null;\n        process.nextTick(this.reject, this.firstError);\n        this.reject = null;\n        this.emit('end', this.firstError);\n      } else {\n        if (this._rows[0].affectedRows !== undefined) {\n          // ok packets, reassemble them if needed\n          let totalAffectedRows = 0;\n          this._rows.forEach((row) => {\n            totalAffectedRows += row.affectedRows;\n          });\n\n          const rs = new OkPacket(\n            totalAffectedRows,\n            this._rows[0].insertId,\n            this._rows[this._rows.length - 1].warningStatus\n          );\n          this.successEnd(rs);\n        } else {\n          // insert with returning\n          if (this._rows.length === 1) {\n            this.successEnd(this._rows[0]);\n          } else {\n            const rs = [];\n            rs.meta = this._rows[0].meta;\n            this._rows.forEach((row) => {\n              Array.prototype.push.apply(rs, row);\n            });\n            rs.meta = this._rows[0].meta;\n            this.successEnd(rs);\n          }\n        }\n        this._columns = null;\n        this._rows = null;\n      }\n      return;\n    }\n\n    if (!this.firstError) {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  throwError(err, info) {\n    this.bulkPacketNo--;\n    if (!this.firstError) {\n      if (err.fatal) {\n        this.bulkPacketNo = 0;\n      }\n      if (this.stack) {\n        err = Errors.createError(err.message, err.errno, info, err.sqlState, this.sql, err.fatal, this.stack, false);\n      }\n      this.firstError = err;\n    }\n\n    if (!this.sending && this.bulkPacketNo === 0) {\n      this.resolve = null;\n      this.emit('send_end');\n      process.nextTick(this.reject, this.firstError);\n      this.reject = null;\n      this.onPacketReceive = null;\n      this.emit('end', this.firstError);\n    } else {\n      this._responseIndex++;\n      this.onPacketReceive = this.readResponsePacket;\n    }\n  }\n\n  /**\n   * Validate that parameters exists and are defined.\n   *\n   * @param info        connection info\n   * @returns {boolean} return false if any error occur.\n   */\n  validateParameters(info) {\n    //validate parameter size.\n    const nbParameter = this.prepare.parameterCount;\n    for (let r = 0; r < this.values.length; r++) {\n      if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];\n\n      //validate parameter is defined.\n      for (let i = 0; i < nbParameter; i++) {\n        if (this.values[r][i] === undefined) {\n          this.emit('send_end');\n          this.throwNewError(\n            `Parameter at position ${i} is not set for values ${r}\\n ${this.displaySql()}`,\n            false,\n            info,\n            'HY000',\n            Errors.ER_PARAMETER_UNDEFINED\n          );\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n\nmodule.exports = BatchBulk;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}